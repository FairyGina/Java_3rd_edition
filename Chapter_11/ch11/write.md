# ch11 컬렉션 프레임워크

## 1. 컬렉션 프레임웍(Collections Framework)

- 컬렉션 프레임웍: 데이터 군을 저장하는 클래스들을 표준화한 설계
- 컬렉션(collection): 다수의 데이터(데이터 그룹)
- 프레임웍: 표준화된 프로그래밍 방식
- JDK1.2 이전에는 Vector, Hashtable, Properties와 같은 컬렉션 클래스, 다수 데이터를 저장할 수 있는 클래스들을 서로 다른 각자의 방식으로 처리해야했으나 그 이후 컬렉션 프레임웍이 등장하며 다양한 종류가 추가되고 모든 컬렉션 클래스를 표준화된 방식으로 다루게 체계화됨
- 컬렉션, 다수의 데이터를 다루는데 필요한 다양하고 풍부한 클래스를 제공하고 인페이스와 다형성을 이용한 객체지향적 설계를 통해 표준화돼 사용법을 익히기에 편리하고 재사용성이 높은 코드 작성 장점

### 1.1. 컬렉션 프레임웍의 핵심 인터페이스

- 컬렉션데이터 그룹: Collection(List, Set), Map
|인터페이스|특징|구현 클래스|
|---|---|---|
|List|순서가 있는 데이터의 집합, 데이터의 중복 허용(예: 대기자 명단)|ArrayList, LinkedList, Stack, Vector 등|
|Set|순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않음|HashSet, TreeSet|
|Map|키(Key)와 값(value)의 쌍(pair)로 이루어진 데이터의 집합으로 순서는 유지되지 않으며, 키는 중복을 허용하지 않고 값은 중복 허용(예: 우편번호, 지역번호(전화번호))|HashMap, TreeMap, Hashtable, Properties 등|

- Vector나 HashTable같은 기존 컬렉션 클래스보다 ArrayList, HashMap 사용 권장

#### Collection인터페이스

- boolean 메서드들은 작업에 성공하거나 사실이면 true, 그렇지 않으면 false 반환

#### List인터페이스

- 중복을 허용하면서 저장순서가 유지되는 컬렉션을 구현하는데 사용

#### Set인터페이스

- 중복을 허용하지 않고 저장순서가 유지되지 않는 컬렉션 클래스를 사용

#### Map인터페이스

- 키(key)와 값(value)을 하나의 쌍으로 묶어 저장하는 컬렉션 클래스를 구현하는데 사용되며 키는 중복될 수 없지만 값은 중복을 허용
- 기존 저장된 데이터와 중복된 키와 값을 저장 시 기존 값은 없어지고 마지막에 저장된 값이 남음
- values() 반환타입: Collections
- KeySet() 반환타입: Set

#### Map.Entry인터페이스

- Map인터페이스의 내부 인터페이스로 내부 클래스와 같이 인터페이스도 인터페이스 안에 인터페이스를 정의하는 내부 인터페이스(inner interface)를 정의하는 것이 가능
- Map에 저장되는 Key-value 쌍을 다루기 위해 내부적으로 Entry인터페이스를 정의해 보다 객체지향적으로 설계하도록 유도하기 위한 것으로 Map인터페이스를 구현하는 클래스에서는 Map.Entry인터페이스도 함께 구현 필요

### 1.2. ArrayList

- 컬렉션 프레임웍에서 가장 많이 사용되는 컬렉션 클래스로 List인터페이스를 구현하기 때문에 데이터의 저장순서가 유지되고 중복을 허용하는 특징을 가짐
- 기존 Vector를 개선한 것으로 Vector의 구현원리와 기능적인 측면에서 동일
- ArrayList는 Object배열을 이용해 데이터를 순차적으로 저장되며, 배열에 더 이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해 기존 배열에 저장된 내용을 새로운 배열로 복사 후 저장
- elementData 이름의 Object 배열을 멤버변수로 선언하고 있으며, 선언된 배열의 타입이 모든 객체의 최고조상인 Object로 모든 종류의 객체를 담을 수 있음
- ArrayList는 List인터페이스를 구현해서 저장된 순서를 유지함
- ArrayList 생성 시, 저장할 요소 갯수를 고려해 실제 저장할 개수보다 여유로운 크기로 하는 것을 권장 => 생성 시 지정한 크기보다 더 많은 객체 저장 시, 자동적으로 크기가 늘어나지만 이 과정에 처리시간이 소요
- 배열을 이용한 자료구조는 데이터를 읽어오고 저장하는데 효율이 좋으나 용량을 변경해야할 시 새로운 배열을 생성 후 기존 배열로부터 새로 생성된 배열로 데이터를 복사해야하기에 효율이 떨어짐. 그렇기에 처음에 인스턴스를 생성 시 저장할 테이터의 개수를 잘 고려해 충분한 용량의 인스턴스 생성 권장
