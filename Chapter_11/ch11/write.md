# ch11 컬렉션 프레임워크

## 1. 컬렉션 프레임웍(Collections Framework)

- 컬렉션 프레임웍: 데이터 군을 저장하는 클래스들을 표준화한 설계
- 컬렉션(collection): 다수의 데이터(데이터 그룹)
- 프레임웍: 표준화된 프로그래밍 방식
- JDK1.2 이전에는 Vector, Hashtable, Properties와 같은 컬렉션 클래스, 다수 데이터를 저장할 수 있는 클래스들을 서로 다른 각자의 방식으로 처리해야했으나 그 이후 컬렉션 프레임웍이 등장하며 다양한 종류가 추가되고 모든 컬렉션 클래스를 표준화된 방식으로 다루게 체계화됨
- 컬렉션, 다수의 데이터를 다루는데 필요한 다양하고 풍부한 클래스를 제공하고 인페이스와 다형성을 이용한 객체지향적 설계를 통해 표준화돼 사용법을 익히기에 편리하고 재사용성이 높은 코드 작성 장점

### 1.1. 컬렉션 프레임웍의 핵심 인터페이스

- 컬렉션데이터 그룹: Collection(List, Set), Map
|인터페이스|특징|구현 클래스|
|---|---|---|
|List|순서가 있는 데이터의 집합, 데이터의 중복 허용(예: 대기자 명단)|ArrayList, LinkedList, Stack, Vector 등|
|Set|순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않음|HashSet, TreeSet|
|Map|키(Key)와 값(value)의 쌍(pair)로 이루어진 데이터의 집합으로 순서는 유지되지 않으며, 키는 중복을 허용하지 않고 값은 중복 허용(예: 우편번호, 지역번호(전화번호))|HashMap, TreeMap, Hashtable, Properties 등|

- Vector나 HashTable같은 기존 컬렉션 클래스보다 ArrayList, HashMap 사용 권장

#### Collection인터페이스

- boolean 메서드들은 작업에 성공하거나 사실이면 true, 그렇지 않으면 false 반환

#### List인터페이스

- 중복을 허용하면서 저장순서가 유지되는 컬렉션을 구현하는데 사용

#### Set인터페이스

- 중복을 허용하지 않고 저장순서가 유지되지 않는 컬렉션 클래스를 사용

#### Map인터페이스

- 키(key)와 값(value)을 하나의 쌍으로 묶어 저장하는 컬렉션 클래스를 구현하는데 사용되며 키는 중복될 수 없지만 값은 중복을 허용
- 기존 저장된 데이터와 중복된 키와 값을 저장 시 기존 값은 없어지고 마지막에 저장된 값이 남음
- values() 반환타입: Collections
- KeySet() 반환타입: Set

#### Map.Entry인터페이스

- Map인터페이스의 내부 인터페이스로 내부 클래스와 같이 인터페이스도 인터페이스 안에 인터페이스를 정의하는 내부 인터페이스(inner interface)를 정의하는 것이 가능
- Map에 저장되는 Key-value 쌍을 다루기 위해 내부적으로 Entry인터페이스를 정의해 보다 객체지향적으로 설계하도록 유도하기 위한 것으로 Map인터페이스를 구현하는 클래스에서는 Map.Entry인터페이스도 함께 구현 필요

### 1.2. ArrayList

- 컬렉션 프레임웍에서 가장 많이 사용되는 컬렉션 클래스로 List인터페이스를 구현하기 때문에 데이터의 저장순서가 유지되고 중복을 허용하는 특징을 가짐
- 기존 Vector를 개선한 것으로 Vector의 구현원리와 기능적인 측면에서 동일
- ArrayList는 Object배열을 이용해 데이터를 순차적으로 저장되며, 배열에 더 이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해 기존 배열에 저장된 내용을 새로운 배열로 복사 후 저장
- elementData 이름의 Object 배열을 멤버변수로 선언하고 있으며, 선언된 배열의 타입이 모든 객체의 최고조상인 Object로 모든 종류의 객체를 담을 수 있음
- ArrayList는 List인터페이스를 구현해서 저장된 순서를 유지함
- ArrayList 생성 시, 저장할 요소 갯수를 고려해 실제 저장할 개수보다 여유로운 크기로 하는 것을 권장 => 생성 시 지정한 크기보다 더 많은 객체 저장 시, 자동적으로 크기가 늘어나지만 이 과정에 처리시간이 소요
- 배열을 이용한 자료구조는 데이터를 읽어오고 저장하는데 효율이 좋으나 용량을 변경해야할 시 새로운 배열을 생성 후 기존 배열로부터 새로 생성된 배열로 데이터를 복사해야하기에 효율이 떨어짐. 그렇기에 처음에 인스턴스를 생성 시 저장할 테이터의 개수를 잘 고려해 충분한 용량의 인스턴스 생성 권장

#### 1.3. LinkedList

- 배열은 가장 기본적인 형태의 자료구조로 구조가 간단하며 사용하기 쉽고 데이터를 읽는데 걸리는 시간(접근시간(access time))이 가장 빠름
- 단점 1. 크기 변경 불가: 크기를 변경할 수 없어 새로운 배열을 생성해 데이터 복사 필요 / 실행속도 향상을 위해 출분히 큰 크기의 배열을 생성해야해서 메모리 낭비
- 단점 2. 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸림: 차례대로 데이터를 추가하고 마지막에서부터 데이터를 삭제하는 것은 빠르나 배열의 중간에 데이터를 추가하려면 빈자리를 만들기 위해 타 데이터들을 복사해서 이동해야함
- 이러한 단점을 보완하기 위해 링크드리스트(linked list) 고안
- 배열은 모든 데이터가 연속적으로 존재하나 링크드리스트는 불연속적으로 존재한느 데이터를 서로 연결(link)한 형태로 구성
- 링크드 리스트 각 요소(node)들은 자신과 연결된 다음 요소에 대한 참조(주소값)와 데이터로 구성
- 링크드 리스트 데이터 삭제: 삭제하고자 하는 요소의 이전 요소가 삭제하고자 하는 요소의 다음 요소를 참조하도록 변경 => 단 하나의 참조만 변경 시 삭제가 이루어짐 => 배열처럼 데이터를 이동하기 위한 복사 과정이 없어 처리속도가 빠름
- 링크드 리스트 데이터 추가: 새로운 요소를 생성한 후 추가하고자 한ㄴ 위치의 이전 요소의 참조를 새로운 요소에 대한 참조로 변경하고, 새로운 요소가 그 다음 요소를 참조하도록 변경
- 링크드 리스트는 이동방향이 단반향이여서 다음 요소에 대한 접근은 쉽지만 이전 요소에 대한 접근은 어려움 => 더블링크드 리스트(이중 연결리스트(double linked list)) 고안
- 더블 링크드 리스트: 단순히 링크드리스트에 참조변수를 하나 더 추가해 다음 요소에 대한 참조 뿐 아니라 이전 요소에 대한 참조가 가능해지도록 하며 그 외는 링크드 리스트와 같음
- 더블 링크드 리스트는 일반 링크드 리스트보다 각 요소에 대한 접근과 이동이 쉬워 링크드 리스트보다 더 많이 사용
- 더블 링크드 리스트의 접근성을 보다 향상시킨 것: 더블 서큘러 링크드 리스트(이중 원형 연결리스트(doubly circular linked list))로 단순히 더블 링크드 리스트의 첫 번째 요소와 마지막 요소를 서로 연결시킴 => 마지막 요소의 다음 요소가 첫 번째 요소고, 첫 번째 요소의 이전 요소가 마지막 요소로 됨
- 실제 LinkedList클래스는 더블 링크드 리스트로 구현되어 있음 => 낮은 접근성(accessability)을 높이기 위해 고안

#### ArrayList와 LinkedList 차이

##### 1. 순차적으로 추가/삭제하는 경우에는 ArrayList가 LinkedList보다 빠름

- ArrayList의 크기가 충분하지 않을 경우, 새로운 크기의 ArrayList를 생성하고 데이터를 복사하는 일이 발생하기에 이 경우는 LinkedList가 빠를 수 있지만 단순 시간으로는 ArrayList가 빠름
- 순차적으로 삭제한다: 마지막 데이터부터 역순으로 삭제한다는 것으로, ArrayList는 마지막 데이터부터 삭제할 경우 각 요소들의 재배치가 필요하지 않아(단지 마지막 요소의 값을 null로만 바꾸기) 빠름

##### 2. 중간 데이터를 추가/삭제하는 경우 LinkedList가 ArrayList보다 빠름

- 중간 요소를 추가 혹은 삭제하는 경우 LinkedList는 각 요소 간 연결만 변경해주면 돼서 처리속도가 상당히 빠름
- ArrayList는 각 요소들을 재배치해 추가할 공간을 확보하거나 빈 공간을 채워야해 처리속도가 늦음

--

- 인덱스가 n인 데이터의 주소: 배열의 주소 + n + 데이터 타입의 크기
- 배열은 각 요소들이 연속적으로 메모리상에 존재하기에 이런 계산이 가능하나 LinkedList는 불연속적으로 위치한 각 요소들이 서로 연결된 것이라 처음부터 n번째 데이터까지 차례대로 따라가야 원하는 값을 얻을 수 있음
=> LinkedList는 저장해야하는 데이터의 개수가 많아질수록 데이터를 읽어오는 시간(접근시간(access time))이 길어진다는 단점 존재
|컬렉션|읽기(접근시간)|추가/삭제|비고|
|---|---|---|---|
|ArrayList|빠르다|느리다|순차적인 추가삭제는 더 빠르나 비효율적인 메모리 사용|
|LinkedList|느리다|빠르다|데이터가 많을수록 접근성이 떨어짐|

- 다루고자 하는 데이터의 개수가 변하지 않는 경우 ArrayList가 최상의 선택이지만, 데이터 개수의 변경이 잦으면 LinkedList를 사용하는 것을 권장
- 처음에 데이터를 저장할 때는 ArrayList를 사용한 후, 작업할 때는 LinkedList로 데이터를 옮겨 작업도 효율을 높일 수 있을 것임
- 컬렉션 프레임웍에 속한 대부분의 컬렉션 클래스들은 서로 변환이 가능한 생성자를 제공해 간단히 다른 컬렉션 클래스로 데이터를 옮길 수 있음

### 1.4. stack과 Queue

- 스택: 마지막에 저장한 데이터를 가장 먼저 꺼내게 되는 LIFO(Last In First Out)구조
- 큐: 처음에 저장한 데이터를 가장 먼저 꺼내게 되는 FIFO(First In First Out)구조
- 스택은 동전통고 ㅏ같은 구조로 양 옆과 바닥이 막혀있어 한 방향으로만 빼는 구조고, 큐는 양 옆만 막혀있고 위아래로 뚫려 한 방향으로는 넣고 한 방향으로는 빼는 파이프와 같은 구조
- 순차적으로 데이터를 추가하고 삭제하는 스택에는 ArrayList와 같은 배열 기반의 컬렉션 클래스가 적합하나, 큐는 데이터를 꺼낼 때마다 빈 공간을 채우기 위해 데이터의 복사가 발생해 비효율적이여서 LinkedList로 구현하는 것이 더 적합
- 자바는 스택을 Stack클래스로 구현하여 제공하나 큐는 Queue인터페이스로만 정의할 뿐 별도 클래스로 제공하지 않음. 다만 Queue인터페이스를 구현한 클래스들이 있어 이들 중 하나를 선택해 사용

#### 인터페이스를 구현한 클래스 찾기

- Java API 문서에서 All Known Implementing Classes 항목 선택

#### Stack직접 구현하기

- EmptyStackException == RuntimeException

#### 스택과 큐의 활용

- 스택의 활용 예: 수식 계산, 수식괄호 검사, 워드프로세서의 undo/redo, 웹브라우저의 뒤로/앞으로
- 큐의 활용 예: 최근 사용문서, 인쇄작업 대기목록, 버퍼(buffer)

#### PriorityQueue

- Queue인터페이스의 구현체 중 하나로, 저장한 순서에 관계없이 우선순위(priority)가 높은 것부터 꺼내게 된다는 특징으로 null 저장 불가(null 저장 시 NullPointerException 발생)
- PriorityException는 저장공간으로 배열을 사용하며, 각 요소를 힙(heap)이라는 자료구조 형태로 저장
- 힙: 이진 트리의 한 종류로 가장 큰 값이나 가장 작은 값을 빠르게 찾을 수 있음
- 우선순위는 숫자가 작은 것부터 출력하는데, 배열에 숫자말고 객체가 저장될 경우 각 객체의 크기를 비교할 방법을 제공해야함.
- Integer과 같은 Number의 자손들은 자체적으로 숫자를 비교(컴파일러가 Integer로 오토박싱)
- 참조변수를 출력하면 PriorityQueue가 내부적으로 갖고 있는 배열의 내용이 출력되는데 저장한 순서와 다르게 저장되는 이유는 힙이라는 자료구조 형태로 저장하기 때문

#### Deque(Double-Ended Queue)

- Queue 변형으로 한 쪽 끝으로만 추가/삭제 할 수 있는 Queue와 달리 양쪽 끝에 추가/삭제가 가능
- 조상은 Queue로 구현체는 ArrayDeque / LinkedList 가 존재

### 1.5. Iterator, ListIterator, Enumeration

- 컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스

#### Iterator

- 컬렉션 프레임웍에서는 컬렉션에 저장된 요소들을 읽어오는 방법을 표준화했는데, 컬렉션에 저장된 각 요소에 접근하는 기능을 가진 Iterator 인터페이스를 정의하고 Collection 인터페이스에는 Iterator(Iterator를 구현한 클래스의 인스턴스)를 반환하는 iterator()를 정의
- Iterator()는 Collection 인터페이스에 정의된 메서드로 Collection인터페이스의 자손인 List / Set에도 포함되어 List / Set 인터페이스를 구현하는 컬렉션은 iterator()가 각 컬렉션의 특징에 맞게 작성
- 컬렉션 클래스에 대해 iterator()를 호출해 Iterator를 얻은 후 반복문, while문을 사용해 컬렉션 클래스의 요소들을 읽어올 수 있음
- ArrayList대신 Collection인터페이스를 구현한 다른 컬렉션 클래스에 대해 동일한 코드 사용 가능 => 첫 줄에서 ArrayList대신 Collection 인터페이스를 구현한 다른 컬렉션 클래스의 객체를 생성하도록 변경
- Iterator를 이용해 컬렉션의 요소를 읽는 방법을 표준화해 코드 재사용성을 높이며, 공통 인터페이스를 정의해 표준을 정의하고 구현해 표준을 따르게 함으로써 코드의 일관성을 유지해 재사용성을 극대화

#### 참조변수 타입을 ArrayList 타입이 아닌 Collection타입으로 한 이유

- 만약 Collection인터페이스를 구현한 타 클래스(예: LinkedList)로 바꿔야할 경우 선언문 하나만 바꾸면 되기에(참조변수 타입이 Collection이기 때문) 편리성 증가

- Map인터페이스를 구현한 컬렉션 클래스는 키(key)와 값(value)을 쌍(pair)으로 저장하기에 iterator()를 직접 호출할 수 없고, keySet() / entrySet()과 같은 메서드를 통해 키와 값을 각각 따로 Set 형태로 얻어 다시 Iterator()를 호출해야 Iterator를 얻을 수 있음
- List클래스들은 저장순서를 유지하기 때문에 Iterator를 이용해 읽어온 결과 역시 저장 순서와 동일하지만 Set클래스들은 각 요소 간 순서가 유지되지 않기에 Iterator를 이용해 저장된 요소들을 읽어와도 처음에 저장된 순서와 같지 않음

#### ListIterator와 Enumeration

- Enumeration: 컬렉션 프레임웍이 만들어지기 이전에 사용하던 것으로 Iterator의 구버전
- ListIterator: Iterator를 상속받아 기능을 추가한 것으로, 컬렉션의 요소에 접근할 때 Iterator는 단방향으로만 이동할 수 있으나 ListIterator는 양방향으로 이동이 가능. 다만 ArrayList / LinkedList와 같이 List인터페이스를 구현한 컬렉션에서만 사용 가능
- Iterator는 단방향으로만 이동해 컬렉션의 마지막 요소에 다다르면 더 이상 사용할 수 없지만 ListIterator는 양방향으로 이동하기에 각 요소 간 이동이 자유로움
*다만 이동하기 전 반드시 hasNext() / hasPrevious()를 호출해 이동할 수 있는지 확인 필요*

