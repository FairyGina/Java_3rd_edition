# ch11 컬렉션 프레임워크

## 1. 컬렉션 프레임웍(Collections Framework)

- 컬렉션 프레임웍: 데이터 군을 저장하는 클래스들을 표준화한 설계
- 컬렉션(collection): 다수의 데이터(데이터 그룹)
- 프레임웍: 표준화된 프로그래밍 방식
- JDK1.2 이전에는 Vector, Hashtable, Properties와 같은 컬렉션 클래스, 다수 데이터를 저장할 수 있는 클래스들을 서로 다른 각자의 방식으로 처리해야했으나 그 이후 컬렉션 프레임웍이 등장하며 다양한 종류가 추가되고 모든 컬렉션 클래스를 표준화된 방식으로 다루게 체계화됨
- 컬렉션, 다수의 데이터를 다루는데 필요한 다양하고 풍부한 클래스를 제공하고 인페이스와 다형성을 이용한 객체지향적 설계를 통해 표준화돼 사용법을 익히기에 편리하고 재사용성이 높은 코드 작성 장점

### 1.1. 컬렉션 프레임웍의 핵심 인터페이스

- 컬렉션데이터 그룹: Collection(List, Set), Map
|인터페이스|특징|구현 클래스|
|---|---|---|
|List|순서가 있는 데이터의 집합, 데이터의 중복 허용(예: 대기자 명단)|ArrayList, LinkedList, Stack, Vector 등|
|Set|순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않음|HashSet, TreeSet|
|Map|키(Key)와 값(value)의 쌍(pair)로 이루어진 데이터의 집합으로 순서는 유지되지 않으며, 키는 중복을 허용하지 않고 값은 중복 허용(예: 우편번호, 지역번호(전화번호))|HashMap, TreeMap, Hashtable, Properties 등|

- Vector나 HashTable같은 기존 컬렉션 클래스보다 ArrayList, HashMap 사용 권장

#### Collection인터페이스

- boolean 메서드들은 작업에 성공하거나 사실이면 true, 그렇지 않으면 false 반환

#### List인터페이스

- 중복을 허용하면서 저장순서가 유지되는 컬렉션을 구현하는데 사용

#### Set인터페이스

- 중복을 허용하지 않고 저장순서가 유지되지 않는 컬렉션 클래스를 사용

#### Map인터페이스

- 키(key)와 값(value)을 하나의 쌍으로 묶어 저장하는 컬렉션 클래스를 구현하는데 사용되며 키는 중복될 수 없지만 값은 중복을 허용
- 기존 저장된 데이터와 중복된 키와 값을 저장 시 기존 값은 없어지고 마지막에 저장된 값이 남음
- values() 반환타입: Collections
- KeySet() 반환타입: Set

#### Map.Entry인터페이스

- Map인터페이스의 내부 인터페이스로 내부 클래스와 같이 인터페이스도 인터페이스 안에 인터페이스를 정의하는 내부 인터페이스(inner interface)를 정의하는 것이 가능
- Map에 저장되는 Key-value 쌍을 다루기 위해 내부적으로 Entry인터페이스를 정의해 보다 객체지향적으로 설계하도록 유도하기 위한 것으로 Map인터페이스를 구현하는 클래스에서는 Map.Entry인터페이스도 함께 구현 필요

### 1.2. ArrayList

- 컬렉션 프레임웍에서 가장 많이 사용되는 컬렉션 클래스로 List인터페이스를 구현하기 때문에 데이터의 저장순서가 유지되고 중복을 허용하는 특징을 가짐
- 기존 Vector를 개선한 것으로 Vector의 구현원리와 기능적인 측면에서 동일
- ArrayList는 Object배열을 이용해 데이터를 순차적으로 저장되며, 배열에 더 이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해 기존 배열에 저장된 내용을 새로운 배열로 복사 후 저장
- elementData 이름의 Object 배열을 멤버변수로 선언하고 있으며, 선언된 배열의 타입이 모든 객체의 최고조상인 Object로 모든 종류의 객체를 담을 수 있음
- ArrayList는 List인터페이스를 구현해서 저장된 순서를 유지함
- ArrayList 생성 시, 저장할 요소 갯수를 고려해 실제 저장할 개수보다 여유로운 크기로 하는 것을 권장 => 생성 시 지정한 크기보다 더 많은 객체 저장 시, 자동적으로 크기가 늘어나지만 이 과정에 처리시간이 소요
- 배열을 이용한 자료구조는 데이터를 읽어오고 저장하는데 효율이 좋으나 용량을 변경해야할 시 새로운 배열을 생성 후 기존 배열로부터 새로 생성된 배열로 데이터를 복사해야하기에 효율이 떨어짐. 그렇기에 처음에 인스턴스를 생성 시 저장할 테이터의 개수를 잘 고려해 충분한 용량의 인스턴스 생성 권장

#### 1.3. LinkedList

- 배열은 가장 기본적인 형태의 자료구조로 구조가 간단하며 사용하기 쉽고 데이터를 읽는데 걸리는 시간(접근시간(access time))이 가장 빠름
- 단점 1. 크기 변경 불가: 크기를 변경할 수 없어 새로운 배열을 생성해 데이터 복사 필요 / 실행속도 향상을 위해 출분히 큰 크기의 배열을 생성해야해서 메모리 낭비
- 단점 2. 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸림: 차례대로 데이터를 추가하고 마지막에서부터 데이터를 삭제하는 것은 빠르나 배열의 중간에 데이터를 추가하려면 빈자리를 만들기 위해 타 데이터들을 복사해서 이동해야함
- 이러한 단점을 보완하기 위해 링크드리스트(linked list) 고안
- 배열은 모든 데이터가 연속적으로 존재하나 링크드리스트는 불연속적으로 존재한느 데이터를 서로 연결(link)한 형태로 구성
- 링크드 리스트 각 요소(node)들은 자신과 연결된 다음 요소에 대한 참조(주소값)와 데이터로 구성
- 링크드 리스트 데이터 삭제: 삭제하고자 하는 요소의 이전 요소가 삭제하고자 하는 요소의 다음 요소를 참조하도록 변경 => 단 하나의 참조만 변경 시 삭제가 이루어짐 => 배열처럼 데이터를 이동하기 위한 복사 과정이 없어 처리속도가 빠름
- 링크드 리스트 데이터 추가: 새로운 요소를 생성한 후 추가하고자 한ㄴ 위치의 이전 요소의 참조를 새로운 요소에 대한 참조로 변경하고, 새로운 요소가 그 다음 요소를 참조하도록 변경
- 링크드 리스트는 이동방향이 단반향이여서 다음 요소에 대한 접근은 쉽지만 이전 요소에 대한 접근은 어려움 => 더블링크드 리스트(이중 연결리스트(double linked list)) 고안
- 더블 링크드 리스트: 단순히 링크드리스트에 참조변수를 하나 더 추가해 다음 요소에 대한 참조 뿐 아니라 이전 요소에 대한 참조가 가능해지도록 하며 그 외는 링크드 리스트와 같음
- 더블 링크드 리스트는 일반 링크드 리스트보다 각 요소에 대한 접근과 이동이 쉬워 링크드 리스트보다 더 많이 사용
- 더블 링크드 리스트의 접근성을 보다 향상시킨 것: 더블 서큘러 링크드 리스트(이중 원형 연결리스트(doubly circular linked list))로 단순히 더블 링크드 리스트의 첫 번째 요소와 마지막 요소를 서로 연결시킴 => 마지막 요소의 다음 요소가 첫 번째 요소고, 첫 번째 요소의 이전 요소가 마지막 요소로 됨
- 실제 LinkedList클래스는 더블 링크드 리스트로 구현되어 있음 => 낮은 접근성(accessability)을 높이기 위해 고안

#### ArrayList와 LinkedList 차이

##### 1. 순차적으로 추가/삭제하는 경우에는 ArrayList가 LinkedList보다 빠름

- ArrayList의 크기가 충분하지 않을 경우, 새로운 크기의 ArrayList를 생성하고 데이터를 복사하는 일이 발생하기에 이 경우는 LinkedList가 빠를 수 있지만 단순 시간으로는 ArrayList가 빠름
- 순차적으로 삭제한다: 마지막 데이터부터 역순으로 삭제한다는 것으로, ArrayList는 마지막 데이터부터 삭제할 경우 각 요소들의 재배치가 필요하지 않아(단지 마지막 요소의 값을 null로만 바꾸기) 빠름

##### 2. 중간 데이터를 추가/삭제하는 경우 LinkedList가 ArrayList보다 빠름

- 중간 요소를 추가 혹은 삭제하는 경우 LinkedList는 각 요소 간 연결만 변경해주면 돼서 처리속도가 상당히 빠름
- ArrayList는 각 요소들을 재배치해 추가할 공간을 확보하거나 빈 공간을 채워야해 처리속도가 늦음

--

- 인덱스가 n인 데이터의 주소: 배열의 주소 + n + 데이터 타입의 크기
- 배열은 각 요소들이 연속적으로 메모리상에 존재하기에 이런 계산이 가능하나 LinkedList는 불연속적으로 위치한 각 요소들이 서로 연결된 것이라 처음부터 n번째 데이터까지 차례대로 따라가야 원하는 값을 얻을 수 있음
=> LinkedList는 저장해야하는 데이터의 개수가 많아질수록 데이터를 읽어오는 시간(접근시간(access time))이 길어진다는 단점 존재
|컬렉션|읽기(접근시간)|추가/삭제|비고|
|---|---|---|---|
|ArrayList|빠르다|느리다|순차적인 추가삭제는 더 빠르나 비효율적인 메모리 사용|
|LinkedList|느리다|빠르다|데이터가 많을수록 접근성이 떨어짐|

- 다루고자 하는 데이터의 개수가 변하지 않는 경우 ArrayList가 최상의 선택이지만, 데이터 개수의 변경이 잦으면 LinkedList를 사용하는 것을 권장
- 처음에 데이터를 저장할 때는 ArrayList를 사용한 후, 작업할 때는 LinkedList로 데이터를 옮겨 작업도 효율을 높일 수 있을 것임
- 컬렉션 프레임웍에 속한 대부분의 컬렉션 클래스들은 서로 변환이 가능한 생성자를 제공해 간단히 다른 컬렉션 클래스로 데이터를 옮길 수 있음

### 1.4. stack과 Queue

- 스택: 마지막에 저장한 데이터를 가장 먼저 꺼내게 되는 LIFO(Last In First Out)구조
- 큐: 처음에 저장한 데이터를 가장 먼저 꺼내게 되는 FIFO(First In First Out)구조
- 스택은 동전통고 ㅏ같은 구조로 양 옆과 바닥이 막혀있어 한 방향으로만 빼는 구조고, 큐는 양 옆만 막혀있고 위아래로 뚫려 한 방향으로는 넣고 한 방향으로는 빼는 파이프와 같은 구조
- 순차적으로 데이터를 추가하고 삭제하는 스택에는 ArrayList와 같은 배열 기반의 컬렉션 클래스가 적합하나, 큐는 데이터를 꺼낼 때마다 빈 공간을 채우기 위해 데이터의 복사가 발생해 비효율적이여서 LinkedList로 구현하는 것이 더 적합
- 자바는 스택을 Stack클래스로 구현하여 제공하나 큐는 Queue인터페이스로만 정의할 뿐 별도 클래스로 제공하지 않음. 다만 Queue인터페이스를 구현한 클래스들이 있어 이들 중 하나를 선택해 사용

#### 인터페이스를 구현한 클래스 찾기

- Java API 문서에서 All Known Implementing Classes 항목 선택

#### Stack직접 구현하기

- EmptyStackException == RuntimeException

#### 스택과 큐의 활용

- 스택의 활용 예: 수식 계산, 수식괄호 검사, 워드프로세서의 undo/redo, 웹브라우저의 뒤로/앞으로
- 큐의 활용 예: 최근 사용문서, 인쇄작업 대기목록, 버퍼(buffer)

#### PriorityQueue

- Queue인터페이스의 구현체 중 하나로, 저장한 순서에 관계없이 우선순위(priority)가 높은 것부터 꺼내게 된다는 특징으로 null 저장 불가(null 저장 시 NullPointerException 발생)
- PriorityException는 저장공간으로 배열을 사용하며, 각 요소를 힙(heap)이라는 자료구조 형태로 저장
- 힙: 이진 트리의 한 종류로 가장 큰 값이나 가장 작은 값을 빠르게 찾을 수 있음
- 우선순위는 숫자가 작은 것부터 출력하는데, 배열에 숫자말고 객체가 저장될 경우 각 객체의 크기를 비교할 방법을 제공해야함.
- Integer과 같은 Number의 자손들은 자체적으로 숫자를 비교(컴파일러가 Integer로 오토박싱)
- 참조변수를 출력하면 PriorityQueue가 내부적으로 갖고 있는 배열의 내용이 출력되는데 저장한 순서와 다르게 저장되는 이유는 힙이라는 자료구조 형태로 저장하기 때문

#### Deque(Double-Ended Queue)

- Queue 변형으로 한 쪽 끝으로만 추가/삭제 할 수 있는 Queue와 달리 양쪽 끝에 추가/삭제가 가능
- 조상은 Queue로 구현체는 ArrayDeque / LinkedList 가 존재

### 1.5. Iterator, ListIterator, Enumeration

- 컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스

#### Iterator

- 컬렉션 프레임웍에서는 컬렉션에 저장된 요소들을 읽어오는 방법을 표준화했는데, 컬렉션에 저장된 각 요소에 접근하는 기능을 가진 Iterator 인터페이스를 정의하고 Collection 인터페이스에는 Iterator(Iterator를 구현한 클래스의 인스턴스)를 반환하는 iterator()를 정의
- Iterator()는 Collection 인터페이스에 정의된 메서드로 Collection인터페이스의 자손인 List / Set에도 포함되어 List / Set 인터페이스를 구현하는 컬렉션은 iterator()가 각 컬렉션의 특징에 맞게 작성
- 컬렉션 클래스에 대해 iterator()를 호출해 Iterator를 얻은 후 반복문, while문을 사용해 컬렉션 클래스의 요소들을 읽어올 수 있음
- ArrayList대신 Collection인터페이스를 구현한 다른 컬렉션 클래스에 대해 동일한 코드 사용 가능 => 첫 줄에서 ArrayList대신 Collection 인터페이스를 구현한 다른 컬렉션 클래스의 객체를 생성하도록 변경
- Iterator를 이용해 컬렉션의 요소를 읽는 방법을 표준화해 코드 재사용성을 높이며, 공통 인터페이스를 정의해 표준을 정의하고 구현해 표준을 따르게 함으로써 코드의 일관성을 유지해 재사용성을 극대화

#### 참조변수 타입을 ArrayList 타입이 아닌 Collection타입으로 한 이유

- 만약 Collection인터페이스를 구현한 타 클래스(예: LinkedList)로 바꿔야할 경우 선언문 하나만 바꾸면 되기에(참조변수 타입이 Collection이기 때문) 편리성 증가

- Map인터페이스를 구현한 컬렉션 클래스는 키(key)와 값(value)을 쌍(pair)으로 저장하기에 iterator()를 직접 호출할 수 없고, keySet() / entrySet()과 같은 메서드를 통해 키와 값을 각각 따로 Set 형태로 얻어 다시 Iterator()를 호출해야 Iterator를 얻을 수 있음
- List클래스들은 저장순서를 유지하기 때문에 Iterator를 이용해 읽어온 결과 역시 저장 순서와 동일하지만 Set클래스들은 각 요소 간 순서가 유지되지 않기에 Iterator를 이용해 저장된 요소들을 읽어와도 처음에 저장된 순서와 같지 않음

#### ListIterator와 Enumeration

- Enumeration: 컬렉션 프레임웍이 만들어지기 이전에 사용하던 것으로 Iterator의 구버전
- ListIterator: Iterator를 상속받아 기능을 추가한 것으로, 컬렉션의 요소에 접근할 때 Iterator는 단방향으로만 이동할 수 있으나 ListIterator는 양방향으로 이동이 가능. 다만 ArrayList / LinkedList와 같이 List인터페이스를 구현한 컬렉션에서만 사용 가능
- Iterator는 단방향으로만 이동해 컬렉션의 마지막 요소에 다다르면 더 이상 사용할 수 없지만 ListIterator는 양방향으로 이동하기에 각 요소 간 이동이 자유로움
*다만 이동하기 전 반드시 hasNext() / hasPrevious()를 호출해 이동할 수 있는지 확인 필요*

### 1.6. Arrays

- Arrays에 정의된 메서드는 모두 static 메서드

#### 배열의 복사 - copyOf(), copyOfRange()

- copyOf(): 배열 전체를 복사해 새로운 배열 생성 후 반환
- copyOfRange(): 배열 일부를 복사해 새로운 배열 생성 후 반환하며 지정된 범위의 끝은 포함X

#### 배열 채우기 - fill(), setAll()

- fill(): 배열의 모든 요소를 지정된 값으로 채움
- setAll(): 배열을 채우는데 사용할 함수형 인터페이스를 매개변수로 받음
- 이 메서드를 호출 시 함수형 인터페이스를 구현한 객체를 매개변수로 지정하던가 아니면 람다식 지정 필요

#### 배열의 정렬과 검색 - sort(), binarySearch()

- sort(): 배열을 정렬
- binarySearch(): 배열에 저장된 요소를 검색할 때 사용하며, 배열에서 지정된 값이 저장된 위치(index)를 찾아 반환하는데, 반드시 배열이 정렬된 상태여야 올바른 결과를 얻음
- 만약 검색한 값과 일치하는 요소들이 여러 개 있다면, 이중 어떤 것의 위치가 반환되는지는 알 수 없음
- 순차 검색(linear search): 배열의 첫 번째 요소부터 순서대로 하나씩 검색하는 것으로 배열이 정렬될 필요는 없지만 배열의 요소를 하나씩 비교해 시간이 많이 걸림
- 이진 검색(binary search): 배열 검색 범위를 반복적으로 절반씩 줄여가며 검색하기에 검색속도가 상당히 빠르며, 큰 배열일 경우 유리하나 정렬될 경우에만 사용 가능

#### 배열의 비교와 출력 - equals(), toString()

- toString() 배열의 모든 요소를 문자열로 편하게 출력 가능하며, 1차원 배열에만 사용 가능. 타차원 배열은 deppTo String()사용헤야함
- deepTo String(): 배열의 모든 요소를 재귀적으로 접근해 문자열을 구성해 2차원, 3차원 이상 배열에도 동작
- equals(): 두 배열에 저장된 모든 요소를 비교해 같으면 true, 다르면 false를 반환하며, 1차원 배열에만 사용 가능, 다차원 배열 비교는 deepEquals() 사용
- 2차원 배열에서는 true여도 1차원 배열로는 false를 얻는데, 다차원 배열은 배열의 배열 형태로 구성해 비교해서 문자열을 비교하는 것이 아닌 배열에 저장된 배열의 주소를 비교함. 따라서 서로 다른 배열은 항상 주소가 다르므로 false를 결과로 얻음

#### 배열을 List로 변환 - asList(Object...a)

- asList(): 배열을 List에 담아 반환하며, 매개변수 타입이 가변인수라 배열 생성없이 저장할 요소들만 나열하는 것이 가능
- asList()가 반환한 List크기 변경이 불가하며, 추가 또는 삭제가 불가능하지만 저장된 내용은 변경 가능

#### parallelXXX(), spliterator(), stream()

- ParallelXXX(): 보다 빠른 결과를 얻기 위해 여러 쓰레드가 작업을 나눠 처리
- spliterator(): 여러 쓰레드가 처리할 수 있게 하나의 작업을 여러 작업으로 나누는 Spliterator를 반환
- Stream(): 컬렉션을 스트림으로 변환

### 1.7. Comparator와 Comparable

- Arrays.sort() 호출 시 Character클래스의 Comparable의 구현에 의해 정렬
- Comparator / Comparable은 모두 인터페이스로 컬렉션을 정렬하는데 필요한 메서드를 정의하며, Comparable를 구현하고 있는 클래스들은 같은 타입의 인스턴스끼리 서로 비교할 수 있는 클래스들, 주로 Integer와 같은 wrapper클래스와 String, Date, File과 같은 것으로 기본적으로 오름차순, 즉 작은 값에서부터 큰 값의 순으로 정렬되도록 구현 => Comparable을 구현한 클래스는 정렬 가능
- compareTo()의 반환값은 int지만 실제 비교하는 두 객체가 같으면 0, 비교 값보다 작으면 음수, 크면 양수를 반환하도록 구현
- compare()도 객체를 비교해서 음수, 0, 양수 중의 하나를 반환하도록 구현
- Comparable을 구현한 클래스들이 기본적으로 오름차순으로 정렬되어 있지만, 내림차순으로 정렬한다던가 타 기준에 의해 정렬하고 싶을 때 Comparator를 구현해 정렬 기준을 제공

- Comparable: 기본 정렬기준을 구현하는데 사용
- Comparator: 기본 정렬기준 외에 다른 기준으로 정렬하고자할 때 사용

- 전에 배운 것과 같이 Arrays.sort()는 배열을 정렬할 때, Comparator를 지정해주지 않으면 저장하는 객체(주로 Comparable를 구현한 클래스의 객체)에 구현된 내용에 따라 정렬
- 문자열의 오름차순 정렬은 공백, 숫자, 대문자, 소문자의 순으로 정렬(유니코드의 순서가 작은 값부터 큰 값으로 정렬)
- 내림차순(descending order): String의 기본 정렬을 반대로 하는 것
- 내림차순 정렬 방법: compareTo() 결과에 -1을 곱하거나 비교하는 객체의 위치를 바꿔 c2.compareTo(c1.compareTo(c1))
- compare()의 매개변수가 Object타입이기 때문에 compareTo()를 바로 호출할 수 없으므로 먼저 Comparable로 형변환해야한다는 것을 의미

### 1.8. HashSet

- HashSet: Set인터페이스를 구현한 가장 대표적인 컬렉션으로 Set인터페이스 특징대로 HashSet은 중복된 요소를 저장하지 않음
- HashSet에 새로운 요소를 추가할 때는 add메서드나 addAll메서드를 사용하는데, 만일 HashSet에 이미 저장되어 있는 요소와 중복된 요소를 추가하고자 한다면 이 메서드들은 false를 반환함으로써 중복된 요소이기 때문에 추가에 실패했다는 것을 알림
- HashSet의 특징을 이용하면, 컬렉션 내 중복 요소들을 쉽게 제거
- ArrayList와 같이 List인터페이스를 구현한 컬렉션과 달리 HashSet은 저장순서를 유지하지 않으므로 저장순서를 유지하고자 한다면 LinkedHashSet을 사용
*HashSet은 내부적으로 HashMap을 이용해 만들어지며, HashSet이란 이름은 해싱(hashing)을 이용해 구현했기 때문에 붙여짐*
- 중복을 제거하는 동시에 저장한 순서를 유지하고자 한다면 HashSet 대신 LinkedHashSet을 사용
- Collection은 인터페이스고 Collections는 클래스
- HashSet은 저장된 순서를 보장하지 않고 자체적인 저장방식에 따라 순서가 결정되기 때문에 LinkedHashSet을 사용 권유
- HashSet의 add메서드는 새로운 요소를 추가하기 전에 기존 저장된 요소와 같은 것인지 판별하기 위해 추가하려는 요소의 equals()와 hashCode()를 호출하기 때문에 equals()와 hashCode()를 목적에 맞게 오버라이딩해야함
- String클래스에서 같은 내용의 문자열에 대한 equals()의 호출결과가 true인 것과 같이 오버라이딩을 해 구현
- 두 객체에 대해 equals메서드를 호출한 결과가 true이면, 두 객체의 해시코드는 반드시 같아야하지만, 두 객체의 해시코드가 같다고 해서 equals메서드의 호출결과가 반드시 true여야 하는 것은 아님

### 1.9. TreeSet

- 이진 검색 트리(binary search tree)라는 자료구조 형태로 데이터를 저장하는 컬렉션 클래스
- 이진 검색 트리는 정렬, 검색, 범위검색(range search)에 높은 성능을 보이는 자료구조이며 TreeSet은 이진 검색 트리의 성능을 향상시킨 레드-블랙 트리(Red-Black tree)로 구현
- Set인터페이스를 구현했으므로 중복된 데이터의 저장을 허용하지 않으며 정렬된 위치에 저장하므로 저장순서를 유지하지도 않음
- 이진 트리(binary tree)는 링크드리스트처럼 여러 개의 노드(node)가 서로 연결된 구조로, 각 노드에 최대 2개의 노드를 연결할 수 있으며 루트(root)라고 불리는 하나의 노드에서부터 시작해서 계속 확장해나갈 수 있음

#### 이진 검색 트리(binary search tree)

- 모든 노드는 최대 두 개의 자식노드를 가질 수 있음
- 왼쪽 자식노드의 값은 부모노드의 값보다 작고 오른쪽 자식노드의 값은 부모 노드의 값보다 커야함
- 노드의 추가 삭제에 시간이 걸림(순차적 저장이 아니기에)
- 검색(범위검색)과 정렬에 유리
- 중복된 값을 저장하지 못함

### 1.10. HashMap과 Hashtable

- Hashtable과 HashMap의 관계는 Vector와 ArrayList 관계와 같아 Hashtable보다 새 버전인 HashMap 사용 권장
- HashMap은 Map을 구현했으므로 Map의 특징인 키(key)와 값(value)을 묶어 하나의 데이터(entry)로 저장한다는 특징을 지님
- 해싱(hashing)을 사용해 많은 양의 데이터를 검색하는데 뛰어난 성능을 보임
- HashMap은 Entry라는 내부 클래스를 정의하고, 다시 Entry타입의 배열을 선언
- 키와 값은 별개의 값이 아니라 서로 관련된 값이기에 각각의 배열로 선언하기 보다 하나의 클래스로 정의해 하나의 배열로 다루는 것이 데이터의 무결성적인 측면에서 더 바람직
- HashMap은 키와 값을 각각 Object 타입으로 저장(Object, Object)해 어떠한 객체도 저장할 수 있지만 키는 주로 String을 대문자 또는 소문자로 통일해 사용
- 키(key): 컬렉션 내 키(key) 중에서 유일해야함
- 값(value): 키(key)와 달리 데이터의 중복 허용
- 키는 저장된 값을 찾는데 사용되는 것으로 컬렉션 내 유일해야 함 => HashMap에 저장된 데이터를 하나의 키로 검색 시 결과가 단 하나여야함
- 