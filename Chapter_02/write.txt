1.1 변수(variable)란?
int age; // 변수 타입 + 변수이름
변수의 초기화: 변수 사용 전 처음으로 값을 저장하는 것

1.3. 변수의 명명 규칙
식별자: 프로그래밍에서 사용하는 모든 이름으로 같은 영역 내 구분되어야함
     1. 대소문자가 구분되며 길이에 제한 없음
     2. 예약어를 사용해서는 안 됨
     3. 숫자로 시작해서는 안됨
     4. 특수문자는 _, $만 허용
예약어(키워드, 리져브드 워드): 프로그래밍 언어의 구문에 사용되는 단어로 클래스나 변수 메서드에 이름으로 사용 불가
프로그래머에 권장되는 규칙
     1. 클래스 이름의 첫 글자는 항상 대소문자
     2. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자
     3. 상수의 이름은 모두 대문자로 여러 단어로 이루어진 경우 _로 구분

2. 변수의 타입
주로 사용하는 값과 종류는 크게 문자와 숫자로 나뉘며 숫자는 정수와 실수로 나누어짐
자료형: 값의 종류에 따라 저장 공간 크기와 저장 형식을 정의한 것
    - 문자형(char)
    - 정수형(byte, short, int, long)
    - 실수형(float, double)
변수 선언 시 저장 값의 특성을 고려해 가장 알맞은 자료형을 변수의 타입으로 선택

기본형과 참조형
자료형은 기본/참조로 나뉨
- 기본형 변수: 실제 값을 저장(8개)
               - 논리형(boolean)
               - 문자형(char)
               - 정수형(byte, short, int, long)
               - 실수형(float, double)
- 참조형 변수: 어떤 값이 저장되어 있는 주소를 값으로 객체의 주소값을 저장하며 기본형 변수 타입의 나머지 타입입
* 자바는 C언어같이 참조형 변수 간 연산 불가로 실제 연산에 사용되는 것은 모두 기본형 변수
참조형 변수 선언 시 변수 타입으로 클래스의 이름을 사용해 클래스의 이름이 참조 변수의 타입이 됨 -> 새로운 클래스를 작성하는 건 세로운 참조형 추가
참조 변수 선언 방법: 클래스 이름 변수 이름(Date today = new Date(); -< 참조변수는 null 혹은 객체 주소 값을 가짐 / 초기화 방법법)
객체 생성 연산자 new 결과는 생성된 객체의 주소로 대입연산자(=)에 의해 참조변수 today에 저장. 참조변수 today를 통해 생성된 객체 사용 가능
지료형(data type)과 타입(type) 차이: 기본형은 저장 값 종류에 따라 구분돼 자료형으로 사용하고 참조형은 객체 종류에 따라 구분돼 타입으로 사용

2.1. 기본형
     - 논리형(boolean(1))
     - 문자형(char(2))
     - 정수형(byte(1), short(2), int(4), long(8))
     - 실수형(float(4), double(8))
     * 문자형 char은 문자 내부적으로 정수(유니코드)로 저장해 정수/실수형 연산 가능, boolean 제외 7개 기본형은 서로 연산과 변환 가능

2.2. 상수와 리터널(constant & literal)
상수(constant): 값을 지정하면 다른 값으로 변경 불가 변수로 선언과 동시에 반드시 초기화(권유유). 싱수 이름은 대문자로 여러 단어 시 _로 구분, 상수는 리터널에 의미있는 이름을 붙여 코드의 이해와 수정을 도움
     선언 방법: 변수 타입 앞에 final 붙이기
리터럴(literal): 프로그래밍 상수 개념은 타 값으로 변경 불가 변수로 기존 상수의 정의로 사용
* 변수(variable): 하나의 값을 저장하기 위한 공간
리터럴 타입 & 접미사
  종류   리터럴                         접미사
- 논리형 false, true                    없음
- 정수형 123, 0b0101, 077, 0xFF, 100L   L(l)(long 타입), 없음(int 타입으로 byte, short타입 변수 값 저장 시 사용), 0b(2진수), 0(8진수), 0x(16진수), 리터널중간에 구분자('_') 사용 가능
- 실수형 3.14, 3.0e8, 1.4f, 0x1.Op-1    f(F)(float 타입), d(D)(double 타입): 실수형의 기본 타입으로 생략 가능(접미사 없을 시 기본 타입), 온점(.), e(10의 제곱: 곱수를 나타내려면(예: e3: 10^3)로 표현), p(2의 제곱)
- 문자형 'A', '1', '\n'                 없음(char 타입): 단 하나의 문자만 저장 가능하며 반드시 하나 필요
- 문자열 "ABC", "123", "A". "true"      없음(string 타입): 빈문자열("") 저장 가능, 연산자 new 사용(생략 가능), 덧셈 연산자(+)로 문자열 결합 가능: 모두 숫자면 두 수를 더하고 -> 숫자, 하나가 string이면 나머지를 string으로 변환 후 결합 -> 문자,
                                                          왼쪽 -> 오른쪽으로 연산 수행, 숫자를 문자열로 변환시킬 때 + 빈 문자열("")로 계산 가능
* 타입이 달라도 저장 범위가 넓은 타입에 좁은 타입을 저장시키는 건 가능, 그 이상이면 컴파일 에러 발생

2.3. 형식화된 출력(printf())
같은 값을 다른 형식으로 출력할 때 사용. 
* 지시자(spectifier): 변수의 값을 여러가지 형식으로 변환
* 줄바꿈기능(%n or \n)
지시자  설명
%b      boolean 형식
%d      decimal 정수 형식
%or     octal 정수 형식
%x(%X)  hexa-decimal 정수 형식
%f      floating-point(부동소수점) 형식: 소수점 6자리까지만 출력(마지막 숫자 반올림)
%e(%E)  exponent(지수) 형식
%c      character(문자) 형식
%s      string(문자열) 형식
%g      값을 간략 표현

2.4. 화면에서 입력받기 - Scanner
     1. import java.util.*; // Scanner 클래스를 사용하기 위한 문장
     2. Scanner scanner = new Scanner(System.in); // Scanner 클래스의 객체 생성
     3. String input = scanner.nextLine(); // 입력받은 내용을 input에 저장
int num = Interger.parseInt(input); // 입력받은 내용을 int 타입의 값으로 변환(Interger.parseInt()메소드가 문자열을 int타입의 정수로 변환, float 타입은 Float.parseFloat())
 * int num = scanner.nextInt(); // 정수를 입력받아 변수 num에 저장

3. 진법
3.1. 10진법과 2진법

3.2. 비트(bit)와 바이트(byte)
비트(binary digit): 한 자리의 2진수
1 비트: 컴퓨터가 값을 저장할 수 있는 최소단위
바이트(byte): 비트 8개를 묶어 데이터의 기본 단위
워드(word): CPU가 한 번에 처리할 수 있는 데이터의 크기. 워드의 크기는 CPU의 성능에 따라 달라짐(예: 32비트 CPU에서 1 워드는 32비트(4바이트))
n비트로 표현 가능 10진수 2^n 개의 값, 0~2^n-1 범위 가능

3.3. 8진법과 16진법
2진법은 0과 1로 값을 표현해 자리수가 상당히 길어지는 단점을 보안하기 위해 8/16진법 사용
2진수 -> 8진수 변환: 2진수를 뒤에서부터 3자리씩 끊어 8진수로 변환
2진수 -> 16진수 변환: 2진수를 뒤에서부터 4자리씩 끊어 16진수로 변환

3.4. 정수의 진법 변환
10진수를 n진수로 변환: 2로 무한 나누기 / 나머지 뒤에서부터 모으기
n진수를 10진수로 변환: 2^n 순으로 계속해서 빼기

3.5. 실수의 진법 변환
10진 소수점수를 2진 소수점수로 변환하는 방법
     1. 10진 소수에 2를 곱함
     2. 1의 결과에 소수부만 가져다가 다시 2를 곱함
     3. 1, 2 과정을 소수부가 0이 될 때까지 반복
     4. 최종에는 곱할때마다 정수부 숫자를 소수에 넣어주면 완성
2진 소수점수를 10진 소수점수로 변환하는 방법
     1. 2진 소수에 10을 곱함
     2. 1의 결과에 소수부만 가져다가 다시 10를 곱함
     3. 1, 2 과정을 소수부가 0이 될 때까지 반복
     4. 최종에는 곱할때마다 정수부 숫자를 소수에 넣어주면 완성

3.6. 음수의 2진 표현 - 2의 보수법
4비트의 양/음수 표현법: 왼쪽의 첫 번째 비트가 0일시 양수(정순), 1이면 음수(역순)
2의 보수법
n의 보수: 더했을 때 n이 되는 수(예: 7의 10의 보수는 3)
2의 보수법: 서로 2의 보수 관계에 있는 두 2진수로 5와 -5처럼 절대값이 같고 부호가 다른 두 10진수를 표현하는 것
음수를 2진수로 표현하기
     1. 절댓값으로 처리
     2. 2진수로 변환
     3. 2의 보수로 변환
2의 보수 구하는 방법: 1의보수 + 1
음수의 2진 표현을 구하는 방법
     1. 음수의 절대값을 2진수로 변환(예: -5의 절대값인 5를 2진수로 변환(0101))
     2. 1)에서 구한 2진수의 1을 0으로 0은 1로 바꿈(`의 보수 구하기)(예: 0101 -> 1010)
     3. 2)의 결과에 1을 더함(2의 보수 구하기, 1의 보수+1)(예: 1010에 1을 더하면 1011이 되고, 이것이 -5의 2진 표현)

4. 기본형(primitive type)
4.1. 논리형 - boolean
true/false(기본값)
논리 구현(대답(yes/no), 스위치(on/off))에 주로 사용
크기: 1byte(자바는 데이터를 다루는 최소단위가 1 byte)
* 자바는 대소문자가 구별됨. 논리형은 소문자

4.2. 문자형 - char
문자가 아닌 문자의 유니코드(정수)가 저장(예: A 입력시 65 저장)
(char ch = 'A') == (char ch = 65)
어떤 문자의 유니코드를 알고 싶은 경우: int code = (int)ch;
형변환(캐스팅(casting)): 어떤 타입(type, 형)을 다른 타입으로 변환하는 것

특수문자 다루기
특수문자                문자 리터럴
tab                     \t
backspace               \b   
form feed               \f
new line                \n
carriage return         \r
역슬래쉬(\)             \\
작은따옴표              \'
큰따옴표                \"
유니코드(16진수)문자    \u유니코드(예: char a='\u0041')

char 타입의 표현 형식
char 타입의 크기: 2byte(16bit)
char 타입의 변수는 문자가 아닌 유니코드(정수)가 저장되고 표현 형식도 정수형과 동일
* 음수를 나타내지 않아 표현 값의 범위가 다름
char 타입의 표현 범위: 0~2^16-1(0~65535)
short 타입의 표현 범위: -2^15~2^15-1(-32768~32767)
short에 65, char에 'A'를 저장하면 같은 65로 저장되지만 출력은 char은 다시 유니코드 문자로 출력하기에 다름

인코딩과 디코딩(encoding & decoding)
문자 인코딩: 문자를 코드로 변환하는 것(예: 'A' -> 65)
문자 디코딩: 코드를 문자로 변환하는 것(예: 'A' <- 65)

아스키(ASCII: American Standard Code for Information Interchange)
정보교환을 위한 미국 표준 코드로 2^7(128)개의 문자 집합을 제공하는 7 bit부호로, 처음 32개 문자는 인쇄/전송 제어용으로 사용되는 제어문자로 출력 불가, 마지막 문자(DEL)를 제외한 33번째 이후 문자는 출력가능한 문자로 기호, 숫자, 영대소문자로 이루어짐
숫자 0~9, 영문자 A~Z, a~z가 연속적 배치 특징이 존재해 프로그래밍에 유용하게 사용

확장 아스키(Extended ASCII)와 한글
남는 1 bit를 활용해 문자를 추가 정의한 확장 아스키로 서유럽에서 일반적으로 사용하는 문자를 포함하는 ISO 8859-1이 대표적
한글을 표현하는 방법
조합형: 초성, 중성, 종성 조합해 한글 표현
완성형: 확장 아스키의 일부 영역(164~254)에 해당하는 두 문자코드를 조합해 한글 표현
조합형은 사용되지 않고 완성형(KSC 5601)에 없는 잘 안 쓰이는 8822글자를 추가한 확장 완성형(CP 949)가 사용되며 이는 한글 윈도우에서 사용하는 문자 인코딩으로 한글 윈도우에서 작성된 문서는 기본적으로 CP 949로 인코딩돼 저장

코드 페이지(code page, cp)
코드 페이지: PC를 사용하는 지역이나 국가에 따라 여러 버전의 확장 아스키로, CP xxx로 이름을 붙여 사용. 한글 위도우: CP 949, 영문 윈도우: CP 437

유니코드(Unicode)
전 세계의 모든 문자를 하나의 통일된 문자집합으로 표현한 코드
처음엔 2 byte만 사용하려 했으나 부족해 21 bit로 확장
* 보충 문자(supplementary character): 새로 추가된 보충 문자로 이 문자들을 표현할 땐 char 타입이 아닌 int 타입으로 사용
유니코드 문자 셋(= 캐릭터 셋): 유니코드에 포함시키고자 하는 문자들의 집합
유니코드 인코딩: 문자 셋에 번호를 붙인 것(UTF - n 식으로 여러 종류 존재)
* 자바는 UTF - 16 사용(모든 문자를 2 byte의 고정크기로 표현)
UTF - 8: 하나의 문자를 1~4 byte 의 가변 크기로 표현
UTF - 16은 모든 문자의 크기가 동일해 문서를 다루기 편하나 문서의 크기가 커짐
UTF - 8은 영문과 숫자는 1 byte, 한글은 3byte여서 문서의 크기가 작지만 가변적이여서 다루기 어려우나 인터넷의 전송 속도가 중요시해져 UTF - 8 인코딩으로 작성된 웹문서가 늘어나는 추세

4.3. 정수형 - byte, short, int, long
byte(1) < short(2) < int(4)(기본 자료형) < long(8)
정수형의 표현 형식과 범위
어떤 진법의 리터럴을 변수에 저장해도 실제로는 2진수로 바뀌어 저장되며, 저장 형식은 정수형과 실수형으로 존재
정수형:             S               | n-1 bit
       부호 비트(양수는 0, 음수는 1)   n: 타입의 크기(단위: bit)
       모든 정수형은 부호있는 정수로 왼쪽의 첫 번째 비트는 부호 비트로 사용, 나머지는 값을 표현하는 데 사용
n비트로 표현할 수 있는 정수의 개수: 2^n개(=2^(n-1)개+2^(n-1)개)
n비트로 표현할 수 있는 부호있는 정수의 범위: 2^n개(-2^(n-1)~2^(n-1)-1)
* 최대값에서 1을 뺘는 이유는 범위에 0이 포함되기 때문(예: byte타입 변수에 저장 가능 값의 범위: -128~127)

정수형의 선택기준
JVM의 피연산자 스택이 피연산자를 4 byte단위로 저장하기에 작은 자료형을 써도 변환하는 연산이 수행하기에 int형을 사용하는 것이 효율적이며, int형 이상을 다룰 시 long 사용

정수형의 오버플로우
오버플로우(overflow): 해당 타입이 표현할 수 있는 값의 범위를 넘어서는 것
최대값 + 1 = 최소값
최소값 - 1 = 최대값
범위 안에 최대값, 최소값 연산 시 값이 범위 내 무한 반복

부호있는 정수의 오버플로우
부호없는 정수(2진수로 0000이 될 때)와 부호있는 정수(부호 비트가 0에서 1이 될 때)는 표현 범위가 달라 오버플로우 발생 시점이 다름

4.4. 실수형 - float, double
실수형의 범위와 정밀도
타입    정밀도  byte
float   7자리   4
double  15자리  8
실수형의 오버플로우는 무한대가 존재하며, 언더플로우가 존재하는데 이 때 값은 0이 됨
int와 float가 같은 4 byte임에도 저장 값의 개수가 다른 이유: 값을 저장하는 형식이 다르기 때문
int: 부호 + 값
float: 부호 + 지수(E:8) + 가수(M:23)
실수형은 오차가 발생하기에 정밀도가 존재하는데, float는 7자리, double은 15자리만큼 정밀한 값 표현 가능
* double을 사용하는 경우 값의 범위보다 정밀도를 목적으로 사용하는 경우가 큼
실수형의 저장형식
float = 1 + 8 + 23 = 4 byte
double = 1+ 11+ 52 = 8 byte
이 표현형식은 IEEE754 표준을 따름
S(부호: Sign bit): 0: 양수, 1: 음수
E(지수: Exponet): 부호있는 정수, 지수의 범위(float: -127 ~ 128, double: -1023 ~ 1024)
M(가수: Mantissa): 실제값을 저장하는 부분 float: 10진수 7자리, double: 10진수 15자리만큼
1. 부호(Sign bit): 정수형과 달리 2의 보수법을 사용하지 않기에 양 - > 음이면 부호비트만 0 -> 1로 변경
2. 지수(Exponent): 127과 128은 숫자 아님(NaN: Not a Number)을 저장하기 위해 실제 사용 가능 지수 범위는 -126 ~ 127로 float 타입의 최대값은 2^127이고, 10진수로 약 10^38, 최소값은 2^-23으로 10^45
3. 가수(Mantissa): 실제 값인 가수를 저장하며 정밀도로 존재

부동소수점의 오차
2진수로는 10진 소수를 정확히 표현하기 어렵기에 가수를 저장할 수 있는 자리수가 한정되어 있어 저장되지 못하고 버려지는 값이 존재하면 오차 발생
발생하는 최대 호차는 약 2^-23으로 이 값은 가수의 마지막 비트의 단위와 같음
7번째 자리는 올림해서 소수점 이해 6자리까지 표현

5. 형변환
5.1. 형변환(캐스팅: casting)이란: 변수 또는 상수의 타입을 다른 타입으로 변환하는 것
모든 변수와 리터럴에는 타입이 존재하는데, 서로 다른 타입 간 연산을 수행하기 위해 연산 수행 전 타입을 일치시킴

5.2. 형변환 방법: 형변환하고자 하는 변수나 리터럴 앞에 변환하고자 하는 타입을 괄호와 함께 붙여줌((타입)피연산자)
괄호()(= 캐스트 연산자, 형변환 연산자)
* 피연산자인 변수는 형변환 이후 아무런 변화 존재 X
기본형에서 boolean을 제외한 나머지 타입들은 서로 형변환이 가능하며, 기본형과 참조형 간의 형변환은 불가능

5.3. 정수형 간의 형변환
값 손실: 큰 타입 -> 작은 타입으로 변환 시 차이나는 크기의 차이만큼 잘리는 것
* 작은 타입 -> 큰 타입일 경우 빈 공간을 0 or 1로 채우며 값 손실 발생 x(기본값은 0이나 변환 값이 음수일 경우 1로 채움(형변환 후에도 부호를 유지하기 위해))
잘리는 위치는 앞에서부터 잘림

5.4. 실수형 간의 형변환
실수형도 정수형과 마찬가지로 큰 타입 -> 작은 타입, 작은 타입 -> 큰 타입 존재
* 기수의 24번째 자리에서 반올림이 발생할 수 있어, 반올림 발생 시 23번째 자리 값이 1이 증가
* float 타입의 범위를 넘는 값을 float로 형변환하는 경우 +=무한대 or +=0를 결과로 얻음음

5.5. 정수형과 실수형 간의 형변환
정수형을 실수형으로 변환: 정규화를 거쳐 변환
실수형을 정수형으로 변환: 소수점 이하는 버려짐(반올림 발생 X)
* 실수이하 소수점을 버리고 남은 정수가 정수형의 저장 범위를 넘는 경우, 정수의 오버플로우 발생

5.6. 자동 형변환
경우에 따라 편의상의 이유로 형변환을 생략할 수 있는데, 형변환이 이루어지지 않는 것은 아니고 컴파일러가 생략된 형변환을 자동으로 추가(예: float f = 1234; // 형변환의 생략: float f = (float)1234;)
* 변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우에 형변환 생략 시 에러 발생
* 하지만 명시적으로 형변환 시 프로그램이 실수가 아닌 의도적인 것으로 간주하고 에러를 발생시키지 않음(예: char ch = (char)1000;)
서로 다른 두 타입 간의 덧셈에서는 두 타입 중 표현범위가 더 넓은 타입으로 형변환해 타입을 일치시킨 후 연산 수행: 값 손실의 위험을 낮춰 올바른 결과를 얻기 위함
산술 변환: 연산과정에서 자동적으로 발생하는 형변환

자동 형변환의 규칙
* 넓은 타입 - > 좁은 타입은 반드시 현변환 연산자 사용 필요
char과 short는 같은 2byte나 범위가 달라 양쪽 다 값 손실 발생 우려로 자동 형변환 수행 x
      0. 컴파일러는 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환함
      1. boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능
      2. 기본형과 참조형은 서로 형변환 x
      3. 서로 다른 변수 간의 연산은 형변환을 하는 것이 원칙이나, 값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략 가능