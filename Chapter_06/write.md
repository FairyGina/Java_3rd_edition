# ch6 객체지향 프로그래밍1

***

## 1. 객체지향언어

===

### 1.1. 객체 지향 언어의 역사

**객체지향이론 기본 개념**: 실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간 상호작용으로 상속, 캡슐화, 추상화 개념을 중심으로 구체적 발전
1960년대 중반 객체지향이론을 프로그래밍언어에 적용한 **시뮬라**(Simula) 탄생

### 1.2. 객체지향언어

===

#### 객체지향언어 특징

1. 코드의 재사용성이 높다: 새 코드를 작성할 때 기존 코드를 이용해 쉽게 작성 가능
2. 코드의 관리가 용이하다: 코드간 관계를 이용해 적은 노력으로 쉽게 코드 변경 가능
3. 신뢰성이 높은 프로그래밍을 가능하게 하다: 제어자와 메서드를 이용해 데이터를 보호하고 올바를 값을 유지하도록 하며, 코드의 중복을 제거해 코드와 불일치로 인한 오동작 방지

***

## 2. 클래스와 객체

===

### 2.1. 클래스와 객체의 정의와 용도

**클래스 정의**: 클래스란 객체를 정의해놓은 것
**클래스의 용도**: 클래스는 객체를 생성하는데 사용
**객체의 정의**: 실제로 존재하는 것으로, 사물이나 개념, 논리같은 유/무형적인 것들
**객체의 용도**: 객체가 가지고 있는 기능과 속성에 따라 다름
**유형의 객체**: 책상, 의자, 자동차, TV와 같은 것
**무형의 객체**: 수학 공식, 프로그램 에러와 같은 논리나 개념

클래스는 단지 객체를 생성하는데 사용하며, 객체 자체는 아님. 우리가 원하는 기능의 객체를 사용하기 위해 클래스로부터 객체를 생성하는 과정이 선행되어야함
    *클래스와 객체 간 관계 예시*: TV설계도(클래스)는 TV(객체)를 정의하며 제작하는 용도로, 클래스(설계도)를 먼저 작성 후 클래스로부터 객체를 생성해 사용
클래스를 만들면 매번 객체에 대한 프로그램을 고민하지 않아도 됨. **JDK(Java Development)**에서 프로그래밍을 위해 많은 수의 유용한 클래스(Java Api)를 기본 제공으로 더 유용하게 프로그램 작성 가능

--

### 2.2. 객체와 인스턴스

**인스턴스화**: 클래스로부터 객체를 만드는 과정
**인스턴스**: 클래스로부터 만들어진 객체
    *예: Tv클래스로부터 만들어진 객체*
**객체와 인스턴스의 차이**: 객체는 모든 인스턴스를 대표하는 포괄적인 의미 / 인스턴스는 어떤 클래스로부터 만들어진 것을 강조하는 구체적인 의미
''' 클래스 - 인스턴스화 -> 인스턴스(객체)'''

--

### 2.3. 객체의 구성요소 - 속성과 기능

**객체**: 멤버(속성 + 기능 집합)
    *클래스란 객체를 정의한 것으로 클래스에는 객체의 모든 속성과 기능이 정의되어 있기에, 클래스로부터 객체를 생성하면 클래스에 정의된 속성과 기능을 가진 객체가 생성됨
**속성(property)**: 멤버변수(member variable), 특성(attribute), 필드(field), 상태(state)
**기능(function)**: 메서드(method), 함수(function), 행위(behavior)
**멤버변수와 메서드를 선언하는데 순서는 관계없지만 일반적으로 메서드보다 멤버변수를 먼저 선언하고 멤버 변수는 멤버 변수끼리, 메서드는 메서드끼리 모아놓는 것이 일반적*
각 변수의 자료형은 속성의 값에 알맞은 것을 선택 *(예: 전원상태(power)은 boolean으로)*

### 2.4. 인스턴스의 생성과 사용

'''
클래스명 변수명;            // 클래스의 객체를 참조하기 위한 참조 변수를 선언
변수명 = new 클래스명();    // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장

Tv t;                      // Tv 클래스 타입의 참조변수 t를 선언
t = new Tv();              // Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장
'''

**인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스 타입과 일치해야함**
참조변수에는 하나의 값(주소)만이 저장될 수 있으므로 둘 이상의 참조변수가 하나의 인스턴스를 가리키는(참조하는) 것이 가능하지만 하나의 참조변수로 여러 개의 인스턴스를 가리키는 것은 가능하지 않음

--

### 2.5. 객체 배열

**객체 배열**: 많은 수의 객체를 다뤄야할 때, 참조변수들을 하나로 묶은 참조 변수 배열
객체 배열을 생성하면 각 요소는 참조변수 기본값인 NULL로 자동 초기화(*예: Tv[] tvArr = new Tv[3]*). 이는 객체를 다루기 위한 참조 변수 생성 단계로 **객체가 저장되지는 않음(예: tvArr[0] = new Tv();)**
기본적으로 객체 배열은 같은 타입의 객체만 저장 가능

--

### 2.6. 클래스의 또 다른 정의

**객체지향이론 관점**: 속성과 기능으로 정의되어 있는 객체를 생성하기 위한 틀
**프로그래밍적 관점**
    **1. 클래스 - 데이터와 함수의 결합**
        프로그래밍 언어에서 데이터 처리를 위한 데이터 저장 형태 발전 과정: **변수 -> 배열 -> 구조체 -> 클래스**
            '''
            **1. 변수**: 하나의 데이터를 저장할 수 있는 공간간
            **2. 배열**: 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
            **3. 구조체**: 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
            **4. 클래스**: 데이터와 함수의 결합(구조체+함수)
            '''

        *하나의 데이터를 저장*하기 위해 **변수**를, *같은 종류의 데이터를 보다 효율적으로 다루기* 위해 **배열**을, 후에 **구조체**가 등장해 *자료형의 종류에 상관없이 서로 관계가 깊은 변수들을 하나로 묶어 다룸*
        함수는 주로 데이터를 가지고 작업해 서로 관계가 깊어 객체지향 언어는 변수(데이터)와 함수를 하나의 클래스로 정의해 서로 관계가 깊은 변수와 함수를 다루게 함
            **클래스**: 서로 관련된 변수들을 정의하고 이들에 대한 작업을 수행하는 함수들을 함께 정의하는 것

    **2. 클래스 - 사용자정의 타입(user - defined type)**
        정의: 프로그래밍 언어에서제공하는 자료형 외 프로그래머가 서로 관련된 변수들을 묶어 하나의 타입으로 새로 추가하는 것
                class로, 타 프로그래밍에도 이러한 방법이 존재.
                기본형 개수: 8 참조형 개수: 무한(*프로그래머가 새로운 타입 추가 가능*)

***

## 3. 변수와 메서드

===

### 3.1 선언 위치에 따른 변수의 종류

--

#### 변수 종류

- 클래스변수: static 붙은 변수 / 클래스가 메모리에 올라갈 때 생성
- 인스턴스변수: static이 없는 변수 / 인스턴스가 생성되었을 때 생성
- 지역변수: 멤버변수(클래스/인스턴스)를 제외한 나머지 모든 변수는 지역변수 / 번수 선언문이 수행됐을 때 생성
*변수의 종류를 결정짓는 중요 요소: *변수의 선언된 위치*

#### 1. 인스턴스변수(instance variable)

- 클래스 영역에 선언, 클래스의 인스턴스를 생성할 때 생성
- 인스턴스 변수의 값을 읽어 오거나 저장하기 위해 먼저 인스턴스 생성
- 독립적인 저장 공간을 가져 서로 다른 값을 가질 수 있음
*고유 상태를 유지해야하는 속성인 경우 인스턴스 변수로 선언*

#### 2. 클래스변수(class variable)

- 클래스 변수 선언 방법: static + 인스턴스 변수
- 모든 인스턴스가 공통된 저장공간(변수) 공유 -> 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성일 시 선언
- 인스턴스 변수는 인스턴스를 생성하고 사용해야하나 클래스 변수는 바로 사용 가능
- 사용 형식: 클래스이름.클래스변수
- 메모리에 로딩될 때 생성되어 프로그램 종료될 때까지 유지
- public을 붙일 시 같은 프로그램 내 어디에서나 접근 가능한 전역변수의 성격을 가짐

#### 3. 지역변수(local variable)

- 메서드 내 선언돼 메서드 내에서만 사용 가능, 메서드 종료 시 사용 불가
*for/while문의 블럭 내 선언된 지역변수는 선언된 블럭 내에서만 사용 가능*

--

### 3.2. 클래스 변수와 인스턴스 변수

인스턴스변수는 인스턴스가 생성될 때마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있으나, 클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로 항상 공통된 값을 가짐

--

### 3.3. 메서드

**메서드(method)**: 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것(==수학의 함수, 블랙박스)

#### 메서드를 사용하는 이유

**1. 높은 재사용성**: 한 번 만든 메서드는 몇 번이고 호출하며 타 프로그램에도 사용 가능
**2. 중복된 코드의 제거**: 반복되는 문장을 엮어 하나의 메서드로 작성하면, 코드의 중복 제거, 변경사항 발생 시 메서드만 수정해 관리가 쉽고 오류 발생 가능성 낮아짐
**3. 프로그램의 구조화**: : main에 여러 개의 메소드를 담아 프로그램의 구조를 단순화

--

### 3.4. 메서드의 선언과 구현

메서드 구성: **선언부(머리) + 구현부(몸통)**

#### 메서드 선언부(method declaration, method header)

반환 타입(출력) + 메서드 이름 + 매개변수 선언(입력)
int add(int x, int y)
*메서드의 선언부는 후에 변경사항이 발생하지 않도록 신중히 작성해야 하는데, 변경 시 메서드가 호출되는 모든 곳도 같이 변경해야하기 때문*

#### 매개변수 선언(parameter declaration)

매개변수는 메서드가 작업을 수행하는데 필요한 값들(입력)을 제공받기 위한 것으로, 필요한 값의 개수만큼 변수를 선언해 각 변수 간 구분은 쉼표(,)를 사용
 *주의: 일반적인 변수 선언과 달리 두 변수의 타입이 같아도 변수의 타입을 생략할 수 없음*
선언할 매개변수의 개수는 제한 X, 값을 입력받지 않아도 되면 괄호 안에 아무것도 안 적어도 됨

#### 메서드의 이름(method name)

- 변수의 명명규칙대로 작성
- 메서드는 특정 작업을 수행하므로 add같은 동사로 짓기도 하며, 이름만으로 메서드 기능을 알 함축적이고 의미있는 이름을 지어야함

#### 반환타입(return)

메서드의 작업수행 결과(출력)인 반환값(return value)의 타입을 적으며, 없을 경우 void

#### 메서드의 구현부(method body, 메서드 몸통)

- 메서드의 선언부 다음에 오는 괄호{}를 메서드의 구현부로 메서드 호출 시 수행될 문장 삽입

#### return문

- 메서드의 반환타입이 void가 아닌 경우, 구현부{} 안에 반드시 'return 반환값' 이 포함되어야함 -> 이 문장은 작업이 수행한 결과인 반환값을 호출한 메서드로 전달
- 전달한 값의 타입은 반환타입과 일치하거나 적어도 자동 형변환이 가능한 것
- 단 하나의 값만 반환 가능, 메서드로의 입력(매개변수)은 여러 개일 수 있으나 반환값(출력)은 최대 하나만 허용

#### 지역변수(local variable)

메서드 내 선언된 변수들은 그 메서드 내에서만 사용할 수 있으므로 서로 다른 메서드일 시 같은 이름의 변수 선언 가능(지역번수)

--

### 3.5. 메서드의 호출

메서드를 정의만 하면 아무 일도 일어나지 않음 -> 호출을 해야만 구현부{} 문장 수행
메서드이름(값1, 값2,...); // 메서드를 호출하는 방법

#### 인자(argument)와 매개변수(parameter)

메서드 호출 시 괄호() 안에 지정해준 값들을 **인자(argument) / 인수**로 불림

- 인자의 개수와 순서는 호출된 메서드에 선언된 매개변수와 일치해야 함
- 인자는 메서드가 호출되면서 매개변수에 대입되므로, 인자의 타입은 매개변수 타입과 일치하거나 자동 형변환이 가능해야 함
*반환 타입이 void가 아닌 경우, 메서드가 작업을 수행하고 반환 값을 대입연산자로 변수에 저장하는 것이 보통이나, 저장하지 않아도 됨*

#### 메서드의 실행흐름

같은 클래스 내 메서드끼리는 참조변수를 사용하지 않고도 서로 호출이 가능하나, static메서드는 같은 클래스 내 인스턴스 메서드 호출 불가
메서드 호출 시 지금까지 실행 중이던 메서드는 실행을 잠시 멈추고 호출된 메서드의 문장들이 실행 -> 호출된 메서드의 작업이 모두 끝나면, 다시 호출한 메서드로 돌아와 이후의 문장들 실행
메서드에 선언된 매개변수에 타 자료형 변수를 삽입해도 자동 형변환돼 return 값 호출 가능. 즉, 자동 형변환이 가능한 매개변수를 사용해야함

--

### 3.6. return문

return문: 현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아감
원래는 반환값이 없어도 return문 사용해야함. 반환타입 void 경우에도 컴파일러가 메서드 마지막에 return;을 자동 추가하기에 있어야 하나, 반환 타입이 void가 아닐 경우는 return 값이 꼭 있어야함. 조건식에 따라 반환값도 추가해야함

#### 반환값(return value)

반환값으로는 변수, 수식 등이 올 수 있음.

#### 매개변수의 유효성 검사

메서드의 구현부{} 작성 시, 제일 먼저 해야할 일은 **매개변수의 값이 적절한지 확인**
적절하지 않은 값이 매개변수를 통해 넘어오면 매개변수의 값 보정 혹은 return문을 사용해 작업 중단 및 호출한 메서드로 돌아가게 코드를 작성해야함.
=> **유효성 검사**

--

### 3.7. JVM의 메모리 구조

응용프로그램 실행 시 JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고, 메모리를 용도에 따라 여러 영역으로 나눠 관리(method area, call stack, heap)
*cv: 클래스변수 lv: 지역변수 iv: 인스턴스 변수*

`Method Area` | 클래스 데이터(cv 포함)
`Call stack` | main(lv 포함)
`Heap` | 인스턴스(iv 포함)

#### 1. 메서드 영역(method area)

프로그램 실행 중 어떤 클래스가 사용 시, JVM은 해당 클래스의 클래스파일(*.class)을 읽어 분석해 클래스에 대한 정보(클래스 데이터)를 이곳에 저장하며 클래스의 클래싀 변수(class variable)도 영역에 함께 생성

#### 2. 호출스택(call stack or execution stack)

매서드 작업에 필요한 메모리 공간을 제공. 메서드 호출 사 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 메모리에 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용되며 메서드가 작업을 마칠 시 할당된 메모리공간은 반환 후 비어짐.
각 메서드를 위한 메모리상 작업공간은 서로 구별되며, 첫 번째로 호출된 메서드를 위한 작업공간이 호출스택의 맨 밑에 마련되고, 첫 번째 메서드 수행 중 타 메서드를 호출 시 첫 번째 메서드의 바로 위에 두 번째로 호출된 메서드를 위한 공간이 마련(스택 형식)
-> 이 때 첫 번째 메서드는 수행을 멈추고, 두 번째 메서드 수행 시작 후 마치면 호출스택의 메모리 공간이 반환되며 첫 번째 메서드가 재수행 -> 첫 번째 메서드도 종료 시 메모리 반환으로 호출스택은 완전히 비워짐.
호출 스택의 제일 상위 메서드가 현재 실행 중 메서드며 나머지는 대기 상태로 존재
*호출 스택을 조사하면 메서드 간 호출 관계와 현재 수행 중 메서드가 어느것인지 확인 가능*

##### 호출스택의 특징

- 메서드 호출 시 수행에 필요한 만큼 메모리를 스택에 할당
- 메서드가 수행을 마치면 메모리 반환 후 스택에서 제거
- 호출 스택의 제일 위에 있는 메서드가 현재 실행 중 메서드
- 아래에 있는 메서드가 바로 위 메서드를 호출한 메서드

반환 타입(return type)이 있는 메서드는 종료되며 결과값을 자신을 호출한 메서드(caller)에게 반환. 대기상태에 있는 호출한 메서드(caller)는 넘겨받은 반화값으로 수행을 계속 진행

#### 3. 힙(heap)

인스턴스가 생성되는 공간으로 프로그램 실행 중 생성되는 인스턴스(인스턴스 변수(instance variable))는 모두 이곳에 저장

**객체를 생성하지 않고 메서드를 호출하고 싶으면 메서드 앞에 static을 붙여야함*

--

### 3.8. 기본형 매개변수와 참조형 매개변수

자바에서는 메서드 호출 시 매개변수로 지정한 값을 메서드의 매개변수에 복사해 넘겨주는데, **매개변수 타입이 기본형일 때 기본형 값이 복사되나 참조형이면 인스턴스 주소가 복사**

- 기본형 매개변수: 변수의 값을 읽기만 가능(read only)
- 참조형 매개변수: 변수의 값을 읽고 변경 가능(read & write)

--

### 3.9. 참조형 반환타입

참조형 타입 값: 객체의 주소
-> 객체 주소 값 반환
메서드 내에 생성한 객체를 main(타)메서드에 사용할 수 있게 하려면 새로운 객체의 주소를 반환해야함.
*그렇지 않으면 메서드 종료 시 새 객체 참조가 사라지며 더 이상 메서드 내 객체를 사용할 방법이 없음*

--

### 3.10. 재귀호출(recursive call)

재귀호출(recursive call): 메서드 내부에서 메서드 자신을 다시 호출하는 것
재귀 메서드: 재귀호출을 하는 메서드
*메서드 호출은 특정 위치에 저장되어 있는 명령들을 수행하는 것일 뿐 타 메서드를 호출하는 것과 차이가 없음*
호출된 메서드는 값에 의한 호출(call by value)를 통해, 원래의 값이 아닌 복사된 값으로 작업하기에 호출한 메서드와 관계없이 독립적인 작업수행 가능
단순 재귀호출은 무한루프에 빠지기에, 탈출할 조건문이 사용해야함

#### 반복문과 재귀호출의 차이

반복문은 그저 같은 문장을 반복 수행
재귀호출은 메서드를 호출할 때 매개변수 복사, 종료, 복귀 주소저장 등 몇 가지가 추가로 필요하기에 반복문보다 재귀호출의 수행시간이 더 오래 걸림

#### 반복문 대신 재귀호출 사용해야할 경우

재귀호출의 논리적 간결함 -> 논리적 오류 감소
재귀호출은 전반적으로 비효율적이기에 논리적 간결함이 필요할 때만 사용
한 메서드가 같은 클래스에 존재할 경우, static임에도 호출할 때 클래스 이름 생략 가능

--

### 3.11. 클래스 메서드(static 메서드)와 인스턴스 메서드

메서드 앞에 static이 붙을 시 클래스 메서드, 아니면 인스턴스 메서드
클래스 메서드는 클래수 변수처럼 객체를 생성하지 않고 클래스이름.메서드이름(매개변수)로 호출 가능하나 인스턴스 메서드는 반드시 객체를 생성해야만 호출 가능

#### 클래스 정의 static 사용해 선언해야하는 경우

클래스는 데이터(변수)와 데이터에 관련된 메서드의 집합으로 같은 클래스 내 메서드와 멤버변수는 밀접한 관계로 존재
인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는, 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드
*인스턴스 변수는 인스턴스(객체)를 생성해야만 만들어지므로 인스턴스 메서드 역시 인스턴스를 생성해야만 호출 가능*
클래스 메서드(static 메서드): 인스턴스와 관계 없는(인스턴스나 인스턴스 변수를 사용하지 않는) 메서드로, 인스턴스를 사용하지 않는 경우 특별한 이유가 없으면 클래스로 선언하는 것이 일반적

##### 1. 클래스 설계 시, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙임

생성된 각 인스턴스는 서로 독립적이기에 각 인스턴스의 변수(iv)는 서로 다른 값을 유지. 그러나 모든 인스턴스에서 같은 값이 유지되어야 하는 변수는 static으로 클래스 변수로 정의

##### 2. 클래스 변수(static 변수)는 인스턴스를 생성하지 않아도 사용할 수 있음

static이 붙은 변수(클래스 변수)는 클래스가 메모리에 올라갈 때 이미 자동적으로 생성되기 때문

##### 3. 클래스 메서드(static 메서드)는 인스턴스 변수 사용 불가

인스턴스변수는 인스턴스가 반드시 존재해야만 사용이 가능한데, 클래스메서드(static 메서드)는 인스턴스 생성 없이 호출 가능하므로 클래스 메서드가 호출됐을 때 인스턴스가 존재하지 않을 수도 있음. 그래서 클래스 메서드에서 인스턴스 변수 사용 금지
*인스턴스 변수나 인스턴스 메서드에서 static이 붙은 멤버들을 사용하는 것은 언제나 가능한데, 인스턴스 변수가 존재한다는 것은 static 변수가 이미 메모리에 존재한다는 것을 의미*

##### 4. 메서드 내 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것 고려

메서드 작업 내용 중 인스턴스 변수를 필요로 한다면, static을 붙일 수 없음. 반대로 인스턴스 변수를 필요로 하지 않으면 static을 붙이는 것을 권장. 메서드 호출시간이 짧아져 성능이 향상되며 static을 안 붙인 메서드(인스턴스 메서드)는 실행 시 호출되어야할 메서드를 찾는 과정으로 추가적인 시간이 더 필요

- 클래스의 멤버변수 중 모든 인스턴스에 공통된 값을 유지해야하는 것이 있는지 보고, 있으면 static을 붙임
- 작성한 메서드 중 인스턴스 변수나 인스턴스 메서드를 사용하지 않는 메서드에 static을 붙이는 것을 고려
*random()과 같은 Math클래스의 메서드는 모두 클래스의 메서드로 Math클래스에는 인스턴스 변수가 하나도 없고 작업 수행 시 필요한 값들을 모두 매개변수로 받아 처리하기 때문*

### 3.12. 클래스 멤버와 인스턴스 멤버간의 참조와 호출

- 같은 클래스에 속한 멤버들 간에 별도의 인스턴스를 생성하지 않고 서로 참조/호출 가능
- 클래스멤버가 인스턴스 멤버를 참조/호출하고자 하는 경우 인스턴스 생성
- 인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, **클래스 멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수 있기 때문**
- 인스턴스멤버간의 호출에는 아무런 문제가 없는 이유: 하나의 인스턴스 멤버가 존재한다는 것은 인스턴스가 이미 생성되었다는 것을 의미해, 타 인스턴스 멤버들도 모두 존재하기 때문

--

## 4. 오버로딩(overloading)

### 4.1. 오버로딩이란?

자바에서는 한 클래스 내 이미 사용하려는 이름과 같은 이름을 가진 메서드가 있더라도 **매개변수의 개수 또는 타입이 다르면**, 같은 이름을 사용해 메서드 정의 가능
*메서드 오버로딩(method overloading)(오버로딩(overloading)): 한 클래스 내 같은 이름의 메서드를 여러 개 정의하는 것*

### 4.2. 오버로딩의 조건

#### 오버로딩 성립 조건

1. 메서드 이름이 같아야 함
2. 매개변수의 개수 또는 타입이 달라야 함

- 메서드의 이름이 같아도 매개변수가 다르면 서로 구별될 수 있기에 오버로딩이 가능한 건데, 이 조건 불만족 시 중복 정의로 간주돼 컴파일 시 에러 발생
- 오버로딩된 메서드들은 매개변수에 의해서만 구별되므로 **반환 타입은 오버로딩을 구현하는데 아무런 영항을 주지 못함**

### 4.3. 오버로딩의 예

오버로딩의 대표적인 예: println메서드
이 메서드는 매개변수로 지정하는 값의 타입에 따라 다른 println메서드가 출력(PrintStream클래스: 10개)

### 4.4. 오버로딩의 장점

1. 만약 메서드도 변수처럼 단지 이름만으로 구별될 경우, 그 때마다 다른 메서드를 만들어야하기에 복잡하나 오버로딩을 사용하면 해결
2. 여러 메서드들이 하나의 이름으로 통합되며 이름만으로 어떤 기능을 하는지 예측이 쉬움
3. 메서드 이름 절약 가능

### 4.5. 가변인자(varargs)와 오버로딩

**가변인자(variable arguments)**:기존은 메서드의 매개변수 개수가 고정적이나 이후 동적으로 지정이 가능해진 기능
타입... 변수명 형식으로 선언

- 가변인자 외 매개변수가 더 있을 시, 가변인자를 매개변수 중 제일 마지막에 선언해야함
- 가변인자의 동작원리: 선언된 메서드를 호출할 때마다 내부적으로 배열을 생성하고 이용
*가변인자 사용은 편리하나 비효율적일 수 있으므로 꼭 필요할 때만 사용*
- 매개변수의 타입을 배열로 할 시, 반드시 인자를 지정해야하며 null/길이: 0인 배열을 인자로 지정해야함
- 가변인자를 오버로딩 할 때 주의사항: 가변인자를 선언한 메서드를 오버로딩 시, 메서드를 호출했을 때 구별하지 못하는 경우가 발생되기에 주의 / 가능하면 가변인자를 사용한 메서드는 오버로딩하지 않는 것이 좋음

--

## 5. 생성자(Constructor)

### 5.1. 생성자란?

**생성자**: 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드
*인스턴스 초기화: 인스턴스변수들을 초기화하는 것*

- 메서드처럼 클래스 내 선언되며, 구조도 메서드와 유사하나 리턴값이 없음
리턴값이 없다는 키워드 void 사용 X, 아무것도 적지 않음

#### 기능

1. 인스턴스 변수의 초기화 작업
2. 인스턴스 생성 시 실행되어야 할 작업을 위해 사용

#### 생성자의 조건

1. 생성자의 이름은 클래스의 이름과 같아야함
2. 생성자는 리턴 값이 없음

생성자 정의 방법
class Card{
    Card(){
        //매개변수가 없는 생성자
    }
    Card(String k, int num){
        //매개변수가 있는 생성자
    }
}

- 연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아님
*생성자는 단순히 인스턴스 변수들의 초기화에 사용되는 조금 특별한 메소드일 뿐, 생성자의 몇 특징을 제외하면 메서드와 다르지 않음*

#### 클래스의 인스턴스 생성 코드 수행 과정

Card c=new Card();

1. 연산자 new에 의해 메모리(heap)에 Card클래스의 인스턴스가 생성
2. 생성자 Card()가 호출되어 수행
3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환돼 참조변수 c에 저장

### 5.2. 기본 생성자(default constructor)

- 모든 클래스에는 반드시 하나 이상의 생성자가 정의되어 있음
- 기본 생성자: 클래스에 생성자를 정의하지 않아도 인스턴스를 생성하게 해주는 컴파일러의 기본 기능으로, 아무런 매개변수 / 내용이 없는 것
클래스이름(){}
Card(){}
*컴파일러가 자동적으로 기본 생성자를 추가해주는 경우는 클래스 내 정의된 생성자가 하나도 없을 때 뿐을 명심*

### 5.3. 매개변수가 있는 생성자

생성자도 메서드처럼 매개변수를 선언해 호출 시 값을 넘겨받아 인스턴스 초기화 작업에 사용 가능
*인스턴스마다 각기 다른 값으로 초기화되어야하는 경우가 많아 매개변수를 사용한 초기화는 매우 유용*

만약 생성자 Car()을 사용하면 인스턴스를 생성 후 인스턴스변수들을 따로 초기화해야하지만, 매개변수가 있는 생성자를 사용하면 인스턴스를 생성함과 동시에 원하는 값으로 초기화 가능
*인스턴스를 생성한 다음 인스턴스변수의 값을 변경하는 것보다 매개변수를 갖는 생성자를 사용하는 것이 코드를 보다 간결하고 직관적으로 만듦*

### 5.4. 생성자에서 다른 생성자 호출하기 - this(), this

- 같은 클래스의 멤버들 간 서로 호출할 수 있는 것처럼 생성자도 서로 호출 가능

#### 생성자 간 호출 조건

1. 생성자의 이름으로 클래스이름 대신 this 사용
2. 한 생성자에서 다른 생성자를 호출할 때 반드시 첫 줄에서만 호출 가능

- 생성자 내 타 생성자를 호출 시 클래스이름(Car)이 아닌 this를 사용해야함
- 생성자에서 타 생성자를 첫 줄에서만 호출이 가능한 이유: 생성자 내 초기화 작덥 도중 타 생성자 호출 시, 호출된 타 생성자 내에서도 멤버변수들의 값을 초기화해 타 생성자를 호출하기 이전 초기화 작업이 무의미해지기 때문
color = c;
this.color = color; //지역 변수 참조 / 클래스 내 인스턴스변수 참조(this 안붙이면 지역변수 간주)
- 생성자의 매개변수로 인스턴스변수들의 초기값을 제공받는 경우가 많아 매개변수와 인스턴스변수의 이름이 일치하는 경우가 많음
*this를 사용하는 것은 인스턴스멤버뿐으로 static메서드(클래스 메서드)에서는 인스턴스 멤버들을 사용할 수 없는 것처럼, this 역시 사용 불가(이유: static 메서드는 인스턴스를 생성하지 않고도 호출될 수 있으므로 static 메서드가 호출된 시점에 인스턴스가 존재하지 않을 수도 있기 때문)*
- 생성자를 포함한 모든 인스턴스메서드에는 자신이 관련된 인스턴스를 가리키는 참조변수 this가 지역변수로 숨겨진 채 존재
- 인스턴스메서드는 특정 인스턴스와 관련된 작업을 하기 때뭉네 자신과 관련된 인스턴스의 정보가 필요하나, static 메서드는 인스턴스와 관련없는 작업을 하므로 인스턴스에 대한 정보가 필요없음
**this**: 인스턴스 자신을 가리키는 **참조변수**. 인스턴스의 주소가 저장되어 있으며 모든 인스턴스메서드에 지역변수로 숨겨진 채 존재
**this().this(매개변수)**: **생성자**, 같은 클래스의 다른 생성자를 호출할 때 사용

### 5.5. 생성자를 이용한 인스턴스의 복사

- 현재 사용중인 인스턴스와 같은 상태를 갖는 인스턴스를 하나 더 만들고자 할 때 생성자 이용
- 두 인스턴스가 같은 상태를 가짐: 두 인스턴스의 모든 인스턴스 변수(상태)가 동일한 값을 갖고 있다는 것
Car(Car c){
    color = c.color;
    gearType = c.geatType;
    door = c.door;
}
- 인스턴스의 상태를 전혀 알지 못해도 똑같은 상태의 인스턴스를 추가로 생성할 수 있음. Java API의 많은 클래스들이 인스턴스 복사를 위한 생성자를 정의해놓음
*Object 클래스에 정의된 clone 메서드를 이용하면 간단히 인스턴스 복사 가능*
- 인스턴스를 복사를 하면 서로 같은 상태를 갖지만, 서로 독립적으로 메모리공간에 존재하는 별도의 인스턴스이므로 한쪽 인스턴스 값이 변경되도 복사한 인스턴스 값이 바뀌지 않음

#### 인스턴스를 생성할 때 결정해야할 2가지 사항

1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
2. 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?

--

## 6. 변수의 초기화

### 6.1. 변수의 초기화

- 정의: 변수를 선언하고 처음으로 값을 저장하는 것으로, 경우에 따라 필수적/선택적이나 가능하면 선언과 동시에 적절한 값으로 초기화하는 것이 바람직
- 멤버변수는 초기화를 하지 않아도 자동으로 변수의 자료형에 맞는 기본값으로 초기화가 되나 **지역변수는 사용하기 전에 반드시 초기화 필요**

#### 멤버변수 초기화 방법

1. 명시적 초기화(explicit initialization)
2. 생성자(constructor)
3. 초기화 블럭(initialization block)
    - 인스턴스 초기화 블럭: 인스턴스변수를 초기화하는데 사용
    - 클래스 초기화 블럭: 클래스변수를 초기화하는데 사용

### 6.2. 명시적 초기화(explicit initialization)

정의: 선언과 동시에 초기화하는 것

int door = 4; // 기본형(primitive type)변수의 초기화
Engine e = new Engine(); // 참조형(referece type)변수의 초기화

명시적 초기화는 간단하고 명료하나, 복잡한 초기화 작업은 초기화 블럭 또는 생성자 사용 필요

### 6.3. 초기화 블럭(initialization block)

#### 초기화 블럭 종류

- 클래스 초기화 블럭: 클래스변수의 복잡한 초기화에 사용
- 인스턴스 초기화 블럭: 인스턴스변수의 복잡한 초기화에 사용

- 초기화 블럭 작성 시, 인스턴스 초기화 블럭은 단순히 클래스 내 블럭{}을 만들고 그 안에 코드 작성
- 클리스 초기화 블럭은 인스턴스 초기화 블럭 앞에 단순히 static을 붙이면 됨
- 초기화 블럭 내에는 메서드 내에서와 같이 조건문, 반복문, 예외처리구문 등을 자유롭게 사용 가능하므로, 초기화 작업이 복잡해 명시적 초기화만으로 부족한 경우 초기화 블럭 사용
- 클래스 초기화 블럭은 클래스가 메모리에 처음 로딩될 때 한번만 수행, 인스턴스 초기화 블럭은 생성자와 같이 인스턴스를 생성할 때마다 수행
- 생성자보다 인스턴스 초기화 블럭이 먼저 수행
*클래스가 처음 로딩될 때 클래스변수들이 자동적으로 메모리에 만들어지고, 곧바로 클래스 초기화블럭이 클래스 변수들을 초기화하게 되는 것*

class InitBlock{
    static { //클래스 초기화 블럭}
    {인스턴스 초기화 블럭}
}

- 인스턴스 변수의 초기화는 주로 생성자를 이용하고, 인스턴스 초기화 블럭은 모든 생성자에서 공통으로 수행돼야하는 코드를 넣는데 사용 -> 코드가 보다 간결
- 코드의 중복을 제거하는 것은 코드의 신뢰성을 높여주고, 오류의 발생 가능성을 줄여줌
- 재사용성을 높이고 중복 제거로 객체지향프로그래밍이 추구하는 목표 달성
*프로그래머는 객체지향언어 요소들을 잘 이해하고 활용해 코드 중복을 최대한 제거하기 위해 노력해야함*
- 클래스 초기화 블럭은 처음 메모리에 로딩될 때 한번만 수행되지만, 인스턴스 초기화 블럭은 인스턴스가 생성될 때마다 수행됨
- 배열이나 예외처리가 필요한 초기화에서는 명시적 초기화만으로는 복잡한 초기화 작업이 어렵기에 추가적으로 클래스 초기화 블럭을 사용하도록 함
*인스턴스변수의 복잡한 초기화는 생성자 또는 인스턴스 초기화 블럭을 사용*

### 6.4. 멤버변수의 초기화 시기와 순서

#### 초기화가 수행된 시기와 순서

- 클래스변수의 초기화 시점: 클래스가 처음 로딩될 때 단 한번 초기화됨
- 인스턴스변수의 초기화 시점: 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어짐

- 클래스변수의 초기와 순서: 기본값 -> 명시적 초기화 -> 클래스 초기화 블럭
- 인스턴스변수의 초기와 순서: 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자

- 프로그램 실행도중 클래스에 대한 정보가 요구될 때, 클래스는 메모리에 로딩
*예: 클래스 멤버 사용 시, 인스턴스 생성할 때 등이 해당*
- 해당 클래스가 이미 메모리에 로딩되어 있을 시, 또다시 로딩 X, 초기화 재수행 X
*클래스의 로딩 시기는 JVM 종류에 따라 좀 다를 수 있는데, 클래스가 필요할 때 바로 메모리에 로딩하도록 설계되기도 하고, 실행효율을 높이기 위해 사용될 클래스들을 프로그램이 시작될 때 미리 로딩하도록 되어있는 것도 있음*

