# ch6 객체지향 프로그래밍1

***

## 1. 객체지향언어

===

### 1.1. 객체 지향 언어의 역사

**객체지향이론 기본 개념**: 실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간 상호작용으로 상속, 캡슐화, 추상화 개념을 중심으로 구체적 발전
1960년대 중반 객체지향이론을 프로그래밍언어에 적용한 **시뮬라**(Simula) 탄생

### 1.2. 객체지향언어

===

#### 객체지향언어 특징

1. 코드의 재사용성이 높다: 새 코드를 작성할 때 기존 코드를 이용해 쉽게 작성 가능
2. 코드의 관리가 용이하다: 코드간 관계를 이용해 적은 노력으로 쉽게 코드 변경 가능
3. 신뢰성이 높은 프로그래밍을 가능하게 하다: 제어자와 메서드를 이용해 데이터를 보호하고 올바를 값을 유지하도록 하며, 코드의 중복을 제거해 코드와 불일치로 인한 오동작 방지

***

## 2. 클래스와 객체

===

### 2.1. 클래스와 객체의 정의와 용도

**클래스 정의**: 클래스란 객체를 정의해놓은 것
**클래스의 용도**: 클래스는 객체를 생성하는데 사용
**객체의 정의**: 실제로 존재하는 것으로, 사물이나 개념, 논리같은 유/무형적인 것들
**객체의 용도**: 객체가 가지고 있는 기능과 속성에 따라 다름
**유형의 객체**: 책상, 의자, 자동차, TV와 같은 것
**무형의 객체**: 수학 공식, 프로그램 에러와 같은 논리나 개념

클래스는 단지 객체를 생성하는데 사용하며, 객체 자체는 아님. 우리가 원하는 기능의 객체를 사용하기 위해 클래스로부터 객체를 생성하는 과정이 선행되어야함
    *클래스와 객체 간 관계 예시*: TV설계도(클래스)는 TV(객체)를 정의하며 제작하는 용도로, 클래스(설계도)를 먼저 작성 후 클래스로부터 객체를 생성해 사용
클래스를 만들면 매번 객체에 대한 프로그램을 고민하지 않아도 됨. **JDK(Java Development)**에서 프로그래밍을 위해 많은 수의 유용한 클래스(Java Api)를 기본 제공으로 더 유용하게 프로그램 작성 가능

--

### 2.2. 객체와 인스턴스

**인스턴스화**: 클래스로부터 객체를 만드는 과정
**인스턴스**: 클래스로부터 만들어진 객체
    *예: Tv클래스로부터 만들어진 객체*
**객체와 인스턴스의 차이**: 객체는 모든 인스턴스를 대표하는 포괄적인 의미 / 인스턴스는 어떤 클래스로부터 만들어진 것을 강조하는 구체적인 의미
''' 클래스 - 인스턴스화 -> 인스턴스(객체)'''

--

### 2.3. 객체의 구성요소 - 속성과 기능

**객체**: 멤버(속성 + 기능 집합)
    *클래스란 객체를 정의한 것으로 클래스에는 객체의 모든 속성과 기능이 정의되어 있기에, 클래스로부터 객체를 생성하면 클래스에 정의된 속성과 기능을 가진 객체가 생성됨
**속성(property)**: 멤버변수(member variable), 특성(attribute), 필드(field), 상태(state)
**기능(function)**: 메서드(method), 함수(function), 행위(behavior)
**멤버변수와 메서드를 선언하는데 순서는 관계없지만 일반적으로 메서드보다 멤버변수를 먼저 선언하고 멤버 변수는 멤버 변수끼리, 메서드는 메서드끼리 모아놓는 것이 일반적*
각 변수의 자료형은 속성의 값에 알맞은 것을 선택 *(예: 전원상태(power)은 boolean으로)*

### 2.4. 인스턴스의 생성과 사용

'''
클래스명 변수명;            // 클래스의 객체를 참조하기 위한 참조 변수를 선언
변수명 = new 클래스명();    // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장

Tv t;                      // Tv 클래스 타입의 참조변수 t를 선언
t = new Tv();              // Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장
'''

**인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스 타입과 일치해야함**
참조변수에는 하나의 값(주소)만이 저장될 수 있으므로 둘 이상의 참조변수가 하나의 인스턴스를 가리키는(참조하는) 것이 가능하지만 하나의 참조변수로 여러 개의 인스턴스를 가리키는 것은 가능하지 않음

--

### 2.5. 객체 배열

**객체 배열**: 많은 수의 객체를 다뤄야할 때, 참조변수들을 하나로 묶은 참조 변수 배열
객체 배열을 생성하면 각 요소는 참조변수 기본값인 NULL로 자동 초기화(*예: Tv[] tvArr = new Tv[3]*). 이는 객체를 다루기 위한 참조 변수 생성 단계로 **객체가 저장되지는 않음(예: tvArr[0] = new Tv();)**
기본적으로 객체 배열은 같은 타입의 객체만 저장 가능

--

### 2.6. 클래스의 또 다른 정의

**객체지향이론 관점**: 속성과 기능으로 정의되어 있는 객체를 생성하기 위한 틀
**프로그래밍적 관점**
    **1. 클래스 - 데이터와 함수의 결합**
        프로그래밍 언어에서 데이터 처리를 위한 데이터 저장 형태 발전 과정: **변수 -> 배열 -> 구조체 -> 클래스**
            '''
            **1. 변수**: 하나의 데이터를 저장할 수 있는 공간간
            **2. 배열**: 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
            **3. 구조체**: 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
            **4. 클래스**: 데이터와 함수의 결합(구조체+함수)
            '''

        *하나의 데이터를 저장*하기 위해 **변수**를, *같은 종류의 데이터를 보다 효율적으로 다루기* 위해 **배열**을, 후에 **구조체**가 등장해 *자료형의 종류에 상관없이 서로 관계가 깊은 변수들을 하나로 묶어 다룸*
        함수는 주로 데이터를 가지고 작업해 서로 관계가 깊어 객체지향 언어는 변수(데이터)와 함수를 하나의 클래스로 정의해 서로 관계가 깊은 변수와 함수를 다루게 함
            **클래스**: 서로 관련된 변수들을 정의하고 이들에 대한 작업을 수행하는 함수들을 함께 정의하는 것

    **2. 클래스 - 사용자정의 타입(user - defined type)**
        정의: 프로그래밍 언어에서제공하는 자료형 외 프로그래머가 서로 관련된 변수들을 묶어 하나의 타입으로 새로 추가하는 것
                class로, 타 프로그래밍에도 이러한 방법이 존재.
                기본형 개수: 8 참조형 개수: 무한(*프로그래머가 새로운 타입 추가 가능*)

***

## 3. 변수와 메서드

===

### 3.1 선언 위치에 따른 변수의 종류

--

#### 변수 종류

- 클래스변수: static 붙은 변수 / 클래스가 메모리에 올라갈 때 생성
- 인스턴스변수: static이 없는 변수 / 인스턴스가 생성되었을 때 생성
- 지역변수: 멤버변수(클래스/인스턴스)를 제외한 나머지 모든 변수는 지역변수 / 번수 선언문이 수행됐을 때 생성
*변수의 종류를 결정짓는 중요 요소: *변수의 선언된 위치*

#### 1. 인스턴스변수(instance variable)

- 클래스 영역에 선언, 클래스의 인스턴스를 생성할 때 생성
- 인스턴스 변수의 값을 읽어 오거나 저장하기 위해 먼저 인스턴스 생성
- 독립적인 저장 공간을 가져 서로 다른 값을 가질 수 있음
*고유 상태를 유지해야하는 속성인 경우 인스턴스 변수로 선언*

#### 2. 클래스변수(class variable)

- 클래스 변수 선언 방법: static + 인스턴스 변수
- 모든 인스턴스가 공통된 저장공간(변수) 공유 -> 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성일 시 선언
- 인스턴스 변수는 인스턴스를 생성하고 사용해야하나 클래스 변수는 바로 사용 가능
- 사용 형식: 클래스이름.클래스변수
- 메모리에 로딩될 때 생성되어 프로그램 종료될 때까지 유지
- public을 붙일 시 같은 프로그램 내 어디에서나 접근 가능한 전역변수의 성격을 가짐

#### 3. 지역변수(local variable)

- 메서드 내 선언돼 메서드 내에서만 사용 가능, 메서드 종료 시 사용 불가
*for/while문의 블럭 내 선언된 지역변수는 선언된 블럭 내에서만 사용 가능*

--

### 3.2. 클래스 변수와 인스턴스 변수

인스턴스변수는 인스턴스가 생성될 때마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있으나, 클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로 항상 공통된 값을 가짐

--

### 3.3. 메서드

**메서드(method)**: 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것(==수학의 함수, 블랙박스)

#### 메서드를 사용하는 이유

**1. 높은 재사용성**: 한 번 만든 메서드는 몇 번이고 호출하며 타 프로그램에도 사용 가능
**2. 중복된 코드의 제거**: 반복되는 문장을 엮어 하나의 메서드로 작성하면, 코드의 중복 제거, 변경사항 발생 시 메서드만 수정해 관리가 쉽고 오류 발생 가능성 낮아짐
**3. 프로그램의 구조화**: : main에 여러 개의 메소드를 담아 프로그램의 구조를 단순화

--

### 3.4. 메서드의 선언과 구현

메서드 구성: **선언부(머리) + 구현부(몸통)**

#### 메서드 선언부(method declaration, method header)

반환 타입(출력) + 메서드 이름 + 매개변수 선언(입력)
int add(int x, int y)
*메서드의 선언부는 후에 변경사항이 발생하지 않도록 신중히 작성해야 하는데, 변경 시 메서드가 호출되는 모든 곳도 같이 변경해야하기 때문*

#### 매개변수 선언(parameter declaration)

매개변수는 메서드가 작업을 수행하는데 필요한 값들(입력)을 제공받기 위한 것으로, 필요한 값의 개수만큼 변수를 선언해 각 변수 간 구분은 쉼표(,)를 사용
 *주의: 일반적인 변수 선언과 달리 두 변수의 타입이 같아도 변수의 타입을 생략할 수 없음*
선언할 매개변수의 개수는 제한 X, 값을 입력받지 않아도 되면 괄호 안에 아무것도 안 적어도 됨

#### 메서드의 이름(method name)

- 변수의 명명규칙대로 작성
- 메서드는 특정 작업을 수행하므로 add같은 동사로 짓기도 하며, 이름만으로 메서드 기능을 알 함축적이고 의미있는 이름을 지어야함

#### 반환타입(return)

메서드의 작업수행 결과(출력)인 반환값(return value)의 타입을 적으며, 없을 경우 void

#### 메서드의 구현부(method body, 메서드 몸통)

- 메서드의 선언부 다음에 오는 괄호{}를 메서드의 구현부로 메서드 호출 시 수행될 문장 삽입

#### return문

- 메서드의 반환타입이 void가 아닌 경우, 구현부{} 안에 반드시 'return 반환값' 이 포함되어야함 -> 이 문장은 작업이 수행한 결과인 반환값을 호출한 메서드로 전달
- 전달한 값의 타입은 반환타입과 일치하거나 적어도 자동 형변환이 가능한 것
- 단 하나의 값만 반환 가능, 메서드로의 입력(매개변수)은 여러 개일 수 있으나 반환값(출력)은 최대 하나만 허용

#### 지역변수(local variable)

메서드 내 선언된 변수들은 그 메서드 내에서만 사용할 수 있으므로 서로 다른 메서드일 시 같은 이름의 변수 선언 가능(지역번수)

--

### 3.5. 메서드의 호출

메서드를 정의만 하면 아무 일도 일어나지 않음 -> 호출을 해야만 구현부{} 문장 수행
메서드이름(값1, 값2,...); // 메서드를 호출하는 방법

#### 인자(argument)와 매개변수(parameter)

메서드 호출 시 괄호() 안에 지정해준 값들을 **인자(argument) / 인수**로 불림

- 인자의 개수와 순서는 호출된 메서드에 선언된 매개변수와 일치해야 함
- 인자는 메서드가 호출되면서 매개변수에 대입되므로, 인자의 타입은 매개변수 타입과 일치하거나 자동 형변환이 가능해야 함
*반환 타입이 void가 아닌 경우, 메서드가 작업을 수행하고 반환 값을 대입연산자로 변수에 저장하는 것이 보통이나, 저장하지 않아도 됨*

#### 메서드의 실행흐름

같은 클래스 내 메서드끼리는 참조변수를 사용하지 않고도 서로 호출이 가능하나, static메서드는 같은 클래스 내 인스턴스 메서드 호출 불가
메서드 호출 시 지금까지 실행 중이던 메서드는 실행을 잠시 멈추고 호출된 메서드의 문장들이 실행 -> 호출된 메서드의 작업이 모두 끝나면, 다시 호출한 메서드로 돌아와 이후의 문장들 실행
메서드에 선언된 매개변수에 타 자료형 변수를 삽입해도 자동 형변환돼 return 값 호출 가능. 즉, 자동 형변환이 가능한 매개변수를 사용해야함

--

### 3.6. return문

return문: 현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아감
원래는 반환값이 없어도 return문 사용해야함. 반환타입 void 경우에도 컴파일러가 메서드 마지막에 return;을 자동 추가하기에 있어야 하나, 반환 타입이 void가 아닐 경우는 return 값이 꼭 있어야함. 조건식에 따라 반환값도 추가해야함

#### 반환값(return value)

반환값으로는 변수, 수식 등이 올 수 있음.

#### 매개변수의 유효성 검사

메서드의 구현부{} 작성 시, 제일 먼저 해야할 일은 **매개변수의 값이 적절한지 확인**
적절하지 않은 값이 매개변수를 통해 넘어오면 매개변수의 값 보정 혹은 return문을 사용해 작업 중단 및 호출한 메서드로 돌아가게 코드를 작성해야함.
=> **유효성 검사**

--

### 3.7. JVM의 메모리 구조

응용프로그램 실행 시 JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고, 메모리를 용도에 따라 여러 영역으로 나눠 관리(method area, call stack, heap)
*cv: 클래스변수 lv: 지역변수 iv: 인스턴스 변수*

`Method Area` | 클래스 데이터(cv 포함)
`Call stack` | main(lv 포함)
`Heap` | 인스턴스(iv 포함)

#### 1. 메서드 영역(method area)

프로그램 실행 중 어떤 클래스가 사용 시, JVM은 해당 클래스의 클래스파일(*.class)을 읽어 분석해 클래스에 대한 정보(클래스 데이터)를 이곳에 저장하며 클래스의 클래싀 변수(class variable)도 영역에 함께 생성

#### 2. 호출스택(call stack or execution stack)

매서드 작업에 필요한 메모리 공간을 제공. 메서드 호출 사 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 메모리에 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용되며 메서드가 작업을 마칠 시 할당된 메모리공간은 반환 후 비어짐.
각 메서드를 위한 메모리상 작업공간은 서로 구별되며, 첫 번째로 호출된 메서드를 위한 작업공간이 호출스택의 맨 밑에 마련되고, 첫 번째 메서드 수행 중 타 메서드를 호출 시 첫 번째 메서드의 바로 위에 두 번째로 호출된 메서드를 위한 공간이 마련(스택 형식)
-> 이 때 첫 번째 메서드는 수행을 멈추고, 두 번째 메서드 수행 시작 후 마치면 호출스택의 메모리 공간이 반환되며 첫 번째 메서드가 재수행 -> 첫 번째 메서드도 종료 시 메모리 반환으로 호출스택은 완전히 비워짐.
호출 스택의 제일 상위 메서드가 현재 실행 중 메서드며 나머지는 대기 상태로 존재
*호출 스택을 조사하면 메서드 간 호출 관계와 현재 수행 중 메서드가 어느것인지 확인 가능*

##### 호출스택의 특징

- 메서드 호출 시 수행에 필요한 만큼 메모리를 스택에 할당
- 메서드가 수행을 마치면 메모리 반환 후 스택에서 제거
- 호출 스택의 제일 위에 있는 메서드가 현재 실행 중 메서드
- 아래에 있는 메서드가 바로 위 메서드를 호출한 메서드

반환 타입(return type)이 있는 메서드는 종료되며 결과값을 자신을 호출한 메서드(caller)에게 반환. 대기상태에 있는 호출한 메서드(caller)는 넘겨받은 반화값으로 수행을 계속 진행

#### 3. 힙(heap)

인스턴스가 생성되는 공간으로 프로그램 실행 중 생성되는 인스턴스(인스턴스 변수(instance variable))는 모두 이곳에 저장

**객체를 생성하지 않고 메서드를 호출하고 싶으면 메서드 앞에 static을 붙여야함*

--

### 3.8. 기본형 매개변수와 참조형 매개변수

자바에서는 메서드 호출 시 매개변수로 지정한 값을 메서드의 매개변수에 복사해 넘겨주는데, **매개변수 타입이 기본형일 때 기본형 값이 복사되나 참조형이면 인스턴스 주소가 복사**

- 기본형 매개변수: 변수의 값을 읽기만 가능(read only)
- 참조형 매개변수: 변수의 값을 읽고 변경 가능(read & write)

--

### 3.9. 참조형 반환타입

참조형 타입 값: 객체의 주소
-> 객체 주소 값 반환
메서드 내에 생성한 객체를 main(타)메서드에 사용할 수 있게 하려면 새로운 객체의 주소를 반환해야함.
*그렇지 않으면 메서드 종료 시 새 객체 참조가 사라지며 더 이상 메서드 내 객체를 사용할 방법이 없음*

--

### 3.10. 재귀호출(recursive call)

재귀호출(recursive call): 메서드 내부에서 메서드 자신을 다시 호출하는 것
재귀 메서드: 재귀호출을 하는 메서드
*메서드 호출은 특정 위치에 저장되어 있는 명령들을 수행하는 것일 뿐 타 메서드를 호출하는 것과 차이가 없음*
호출된 메서드는 값에 의한 호출(call by value)를 통해, 원래의 값이 아닌 복사된 값으로 작업하기에 호출한 메서드와 관계없이 독립적인 작업수행 가능
단순 재귀호출은 무한루프에 빠지기에, 탈출할 조건문이 사용해야함

#### 반복문과 재귀호출의 차이

반복문은 그저 같은 문장을 반복 수행
재귀호출은 메서드를 호출할 때 매개변수 복사, 종료, 복귀 주소저장 등 몇 가지가 추가로 필요하기에 반복문보다 재귀호출의 수행시간이 더 오래 걸림

#### 반복문 대신 재귀호출 사용해야할 경우

재귀호출의 논리적 간결함 -> 논리적 오류 감소
재귀호출은 전반적으로 비효율적이기에 논리적 간결함이 필요할 때만 사용
한 메서드가 같은 클래스에 존재할 경우, static임에도 호출할 때 클래스 이름 생략 가능

--

### 3.11. 클래스 메서드(static 메서드)와 인스턴스 메서드

메서드 앞에 static이 붙을 시 클래스 메서드, 아니면 인스턴스 메서드
클래스 메서드는 클래수 변수처럼 객체를 생성하지 않고 클래스이름.메서드이름(매개변수)로 호출 가능하나 인스턴스 메서드는 반드시 객체를 생성해야만 호출 가능

#### 클래스 정의 static 사용해 선언해야하는 경우

클래스는 데이터(변수)와 데이터에 관련된 메서드의 집합으로 같은 클래스 내 메서드와 멤버변수는 밀접한 관계로 존재
인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는, 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드
*인스턴스 변수는 인스턴스(객체)를 생성해야만 만들어지므로 인스턴스 메서드 역시 인스턴스를 생성해야만 호출 가능*
클래스 메서드(static 메서드): 인스턴스와 관계 없는(인스턴스나 인스턴스 변수를 사용하지 않는) 메서드로, 인스턴스를 사용하지 않는 경우 특별한 이유가 없으면 클래스로 선언하는 것이 일반적

##### 1. 클래스 설계 시, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙임

생성된 각 인스턴스는 서로 독립적이기에 각 인스턴스의 변수(iv)는 서로 다른 값을 유지. 그러나 모든 인스턴스에서 같은 값이 유지되어야 하는 변수는 static으로 클래스 변수로 정의

##### 2. 클래스 변수(static 변수)는 인스턴스를 생성하지 않아도 사용할 수 있음.

static이 붙은 변수(클래스 변수)는 클래스가 메모리에 올라갈 때 이미 자동적으로 생성되기 때문

##### 3. 클래스 메서드(static 메서드)는 인스턴스 변수 사용 불가

인스턴스변수는 인스턴스가 반드시 존재해야만 사용이 가능한데, 클래스메서드(static 메서드)는 인스턴스 생성 없이 호출 가능하므로 클래스 메서드가 호출됐을 때 인스턴스가 존재하지 않을 수도 있음. 그래서 클래스 메서드에서 인스턴스 변수 사용 금지
*인스턴스 변수나 인스턴스 메서드에서 static이 붙은 멤버들을 사용하는 것은 언제나 가능한데, 인스턴스 변수가 존재한다는 것은 static 변수가 이미 메모리에 존재한다는 것을 의미*

##### 4. 메서드 내 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것 고려

메서드 작업 내용 중 인스턴스 변수를 필요로 한다면, static을 붙일 수 없음. 반대로 인스턴스 변수를 필요로 하지 않으면 static을 붙이는 것을 권장. 메서드 호출시간이 짧아져 성능이 향상되며 static을 안 붙인 메서드(인스턴스 메서드)는 실행 시 호출되어야할 메서드를 찾는 과정으로 추가적인 시간이 더 필요

- 클래스의 멤버변수 중 모든 인스턴스에 공통된 값을 유지해야하는 것이 있는지 보고, 있으면 static을 붙임
- 작성한 메서드 중 인스턴스 변수나 인스턴스 메서드를 사용하지 않는 메서드에 static을 붙이는 것을 고려
*random()과 같은 Math클래스의 메서드는 모두 클래스의 메서드로 Math클래스에는 인스턴스 변수가 하나도 없고 작업 수행 시 필요한 값들을 모두 매개변수로 받아 처리하기 때문*

