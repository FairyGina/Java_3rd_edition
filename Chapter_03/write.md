1. 연산자(operator)
연산자: 연산을 수행하는 기호(예: '+': 덧셈 연산자)

1.1. 연산자와 피연산자
연산자(operator): 연산을 수행하는 기호(+=*/등)
피연산자(operand): 연산자의 작업 대상(변수, 상수, 리터럴, 수식)
연산자는 피연산자로 연산을 수행하고 나면 항상 결과값을 반환

1.2. 식과 대입연산자
식: 연산자와 피연산자를 조합해 계산하고자 하는 바를 표현한 것
식을 평가: 식을 계산하여 결과를 얻는 것
* 하나의 식을 평가하면, 단 하나의 결과를 얻음

1.3. 연산자의 종류
산술/비교/논리/대입/기타
피연산자의 개수에 의한 분류
     단항 연산자: 피연산자의 개수가 1
     이항 연산자: 피연산자의 개수가 2
     삼항 연산자: 피연산자의 개수가 3
연산자를 기능별, 피연산자의 개수별로 나누어 분류하는 것은 연산자의 우선순위 때문

1.4. 연산자의 우선순위와 결합 규칙
연산자의 결합 규칙: 하나의 식에 같은 우선순위 연산자들이 여러 개 있을 경우, 어떤 순서로 연산을 수행하는지에 대한 규칙
단항/대입 연산자: 오른쪽 - > 왼쪽
그 외: 왼쪽 - > 오른쪽
연산자의 우선순위
1. 산술 > 비교 > 논리 > 대입으로 대입이 제일 마지막으로 수행
2. 단항(1) > 이항(2) > 삼항 (3)
3. 단항/대입 연산자를 제외한 모든 연산 진행 방향은 왼 -> 오 방향

1.5. 산술 변환(usual arithmetic conversion)(= 일반 산술 변환): 연산 전 피연산자 타입의 일치를 위해 자동 형변환되는 것
산술 변환 규칙
     1. 두 피연산자의 타입을 같게 일치(보다 큰 타입으로 일치): 피연산자의 값손실 최소화
     2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환: 정수형의 기본 타입인 int가 가장 효율적으로 처리 가능
* 연산 결과는 피연산자의 타입과 일치

2. 단항 연산자
2.1. 증감 연산자 ++ --
증감 연산자(++): 피연산자의 값을 1 증가
감소 연산자(--): 피연산자의 값을 1 감소
* 정수, 실수가 모두 가능하나 상수 값은 변경 불가로 사용 X
* 오직 대입/증감 연산자만 피연산자 값 변경
전위형: 값이 참조되기 전에 증가(j = ++i;)
후위형: 값이 참조된 후 증가(j = i++;)
* 증감 연산자가 수식이나 메서드 호출에 포함되지 않고 독립적인 하나의 문장으로 쓰이는 경우 전/후위형의 차이 X
원활한 코드 사용: 하나의 식에서 증감 연산자의 사용을 최소화, 식에 두 번 이상 포함된 변수에 증감 연산자를 사용하는 것은 피하기

2.2. 부호 연산자 + - 
부호 연산자 -: 피연산자 부호를 반대로 변경
부호 연산자 +: 하는 거 없음
* boolean형과 char형을 제외한 기본형에만 사용 가능

3. 산술 연산자
3.1. 사칙 연산자 +-*/
0으로 나눌 수는 없음(에러 발생)
* 부동 소수점 0.0f, 0.0d로 나누는 것은 가능하나 결과는 infinity(무한대)
* 리터럴 연산 주의

3.2. 나머지 연산자 %: 왼쪽의 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 결과로 반환하는 연산자로 주로 홀짝, 배수 검사에 사용용
* 0 사용 X
나누는 수로 음수도 허용하나 부호는 무시됨

4. 비교 연산자: 두 피연산자를 비교하는 데 사용하는 연산자로, 연산 결과는 오직 true/false만 반환. 주로 조건문/반복문의 조건식에 사용
* 비교할 피연산자 타입이 다를 경우 자동 형변환 이루어짐
4.1. 대소비교 연산자 < > <= >=: 두 피연산자의 값의 크기를 비교하는 연산자로 참: true, 거짓: false
boolean형과 참조형 제외 사용 가능

4.2. 등가비교 연산자 == !=: 두 피연산자의 값이 같은지 또는 다른지를 비교하는 연산자
모든 자료형에 사용 가능, 기본형과 참조형 비교 X
실수형은 근사밗으로 저장되므로 같은 값을 비교해도 오차 발생해 주의

문자열의 비교
문자열을 비교할 때는 == 대신 equals()라는 메소드 사용. 같으면 true, 다르면 false 반환
* 내용이 같아도 다른 객체일시 ==: false, equals: true 반환
대소문자 구별하지 않고 비교: equalsIgnoreCase() 

5. 논리 연산자: 둘 이상이ㅡ 조건을 AND / OR로 연결해 하나의 식으로 표현하게 하는 연산자
5.1. 논리 연산자 && || !

효율적인 연산(short circult evalution)
같은 조건식이라도 피연산자의 위치에 따라 연산속도가 달라짐

논리 부정 연산자 !: 토글 버튼을 논리적 구현 가능
이해하기 쉬운 식으로 작성 목적

5.2. 비트 연산자 & | ^ << >>
|(OR 연산자): 특정 비트 값 변경
&(AND 연산자): 특정 비트 값 뽑을 때
^(XOR 연산자): 간단한 암호화
비트 연산에도 산술 변환 일어날 수 있음

~(비트 전환 연산자): !처럼 0 -> 1, 1 -> 0으로 바꿔서 보수 연산자로 불림

<< >>(쉬프트 연산자): 피연산자의 각 자리를 왼/오로 이동하는 연산자로 자리이동으로 저장범위를 벗어난 값은 버려지고 빈자리는 0으로 채워짐
                     연산 결과 int 타입이나 타 연산자처럼 타입 일치 불필요로 산술 변환 적용 X
x << n == x*2^n
x >> n == x/2^n
x << n 에서 n의 값이 자료형의 bit수보다 클 경우, 자료형의 bit로 나눈 나머지만큼 이동
연산속도는 빠르나 프로그램 가독성이 떨어지므로 실행 속도를 요구하는 곳에서 사용 권장

6. 그 외의 연산자
6.1. 조건 연산자 ? : 
하나 뿐인 삼항 연산자로 첫 번째 피연산자인 조건식의 평가 겨로가에 따라 다른 결과를 반환(true: 식1, false: 식2)
* 가독성을 위해 괄호를 쓰는 경우가 있으나 필수가 아님

6.2. 대입 연산자 = op=
변수와 같은 저장공간에 값 또는 수식의 연산결과를 저장하는 데 사용
오른쪽 피연산자의 값(식: 평가값)을 왼쪽 피연산자에 저장하고 저장 값을 연산결과로 반환
가장 낮은 우선순위로 진행 방향 오(rvalue) -> 왼(lvalue)

복합 대입 연산자
대입 연산자는 타 연산자(op)와 결합해 사용 가능능