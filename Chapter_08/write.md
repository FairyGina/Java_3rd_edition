# ch8 예외처리

## 예외처리(exception handling)

### 1.1. 프로그램 오류

- 프로그램 에러/오류: 프로그램이 실행 중 어떤 원인에 의해 오작동을 하거나 비정상적으로 종료되는 경우를 초래하는 원인
- 발생 시점에 따라 컴파일 에러(compile-time-error) / 런타임 에러(runtime error)로 나뉨
- 컴파일 에러: 컴파일할 때 발생하는 에러
- 런타임 에러: 프로그램의 실행 도중 발생하는 에러
- 논리적 에러(logical error): 컴파일도 잘 되고 실행도 잘 되지만 의도한 것과 다르게 동작하는 것
- 소스코드를 컴파일 시 컴파일러가 소스코드(*.java)에 대해 오타나 잘못된 구문, 자료형 체크 등 기본적인 검사를 수행해 오류가 있는지를 알려줌
- 컴파일러가 알려준 에러들을 모두 수정해 컴파일을 성공적으로 마치면 클래스 파일(*.class)이 생성되고 생성된 클래스 파일 실행이 가능해짐
- 컴파일러가 기본적인 에러는 걸러주지만, 실행 도중 발생하는 잠재적인 오류까지 검사할 수 없어 컴파일은 잘 돼도 실행 중 에러에 의해 잘못된 결과를 얻거나 프로그램이 비정상 종료될 수 있음
- 자바는 실행 시(runtime) 발생할 수 있는 프로그램 오류를 에러(eroor) / 예외(exception)로 구분
- 에러: 메모리 부족(OutOfMemoryError)이나 스택오버플로우(StackOverflowError) 같이 일단 발생하면 복구 불가 심각한 오류
- 예외: 발생하더라도 수습가능한 다소 미약한 오류
- 에러 발생 시, 프로그램의 비정상적인 종료를 막을 수 없지만 예외는 발생해더 프로그래머가 이에 대한 적절한 코드를 미리 작성함으로써 프로그램의 비정상적인 종료를 막을 수 있음

### 1.2. 예외 클래스의 계층 구조

- 자바는 실행 시 발생할 수 있는 오류(Exception / Error)를 클래스로 정의
- 모든 클래스의 조상은 Object 클래스로 Exception / Error 클래스는 Object 클래스의 자손들로 존재
- 모든 예외의 최고 조상은 Exception 클래스

#### 예외 클래스의 나눠지는 두 그룹

1. Exception클래스와 그 자손들
2. RuntimeException클래스와 그 자손들

- RuntimeException 클래스들은 주로 프로그래머의 실수에 의해 발생될 수 있는 예외들로 자바 프로그램 요소들과 관계가 깊음
*예: 배열의 범위 벗어남(ArrayIndexOutOfBoundsException), 값이 null인 참조변수의 멤버를 호출(NullPointerException), 클래스 간 형변환 실수(ClassCastException), 정수를 0으로 나누려는 것(ArithmeticException)하는 경우*
- Exception클래스들은 주로 외부 영향으로 발생할 수 있는 것들로, 프로그램의 사용자들 동작에 의해 발생되는 경우가 많음
*예: 존재하지 않는 파일의 이름 입력(FileNotFoundException), 실수로 클래스의 이름을 잘못 적음(ClassNotFoundException), 입력 데이터 형식이 잘못됨(DataFormatException)*
- Exception클래스들: 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외
- RuntimeException클래스들: 프로그래머의 실수로 발생하는 예외

### 1.3. 예외처리하기 - try-catch문

- 예외처리(exception handling): 프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성하는 것
- 예외처리 목적: 예외의 발생으로 인한 실행 중인 프로그램의 갑작스런 비정상 종료를 막고, 정상적인 실행상태를 유지할 수 있도록 하는 것
- 발생한 예외를 처리하지 못할 시, 프로그램은 비정상적 종료로 처리되지 못한 예외(uncaught exception)는 JVM의 예외처리기(UncaughtExceptionHandler)가 받아 예외의 원인을 화면에 출력
- 예외를 처리하기 위해 try-catch문 사용
- 하나의 try블럭 다음에 여러 종류의 예외를 처리할 수 있도록 하나 이상의 catch블럭이 올 수 있으며, 이 중 발생한 예외의 종류와 일치하는 단 한 개의 catch 블럭만 수행되며, 발생한 예외의 종류와 일치한느 catch블럭이 없으면 예외 처리되지 않음
*if문과 달리 try블럭이나 catch 블럭 내 포함된 문장이 하나뿐이여도 괄호{} 생략 불가*
- catch 블럭 내 또 하나의 try-catch문이 포함된 경우, 같은 이름의 참조변수를 사용해서는 안됨
- 각 catch블럭에 선언된 두 참조변수의 영역이 서로 겹치므로 다른 이름을 사용해 서로 구별하게 해야함

### 1.4. try-catch문에서의 흐름

- 예외가 발생한 경우와 발생하지 않았을 때의 흐름(문장의 실행순서)이 달라짐

#### 두 가지 경우에 따른 문장 실행순서 정리

##### try블럭 내에서 예외가 발생하는 경우

1. 발생한 예외와 일치하는 catch 블럭이 있는지 확인
2. 일치하는 catch블럭을 찾을 시, 그 catch블럭 내 문장들을 수행하고 전체 try-catch문을 빠져나와서 그 다음 문장을 계속해서 수행하며, 만약 일치하는 catch블럭을 찾지 못하면, 예외는 처리 불가

##### try블럭 내에서 예외가 발생하지 않은 경우

1. catch 블럭을 거치지 않고 전체 try-catch문을 빠져나와 수행을 계속함

- try 블럭에서 예외가 발생 시, 예외가 발생한 위치 이후에 있는 try 블럭의 문장들은 수행되지 않으므로, try 블럭에 포함시킬 코드의 범위를 잘 선택해야함

### 1.5. 예외의 발생과 catch 블럭

- catch 블럭은 괄호()와 블럭{} 두 부분으로 나눠져있는데, 괄호() 내에는 처리하고자 하는 예외와 같은 타입의 참조변수 하나 선언 필요
- 예외 발생 시, 발생한 예외에 해당하는 클래스의 인스턴스가 생성
- 첫 번째 catch 블럭부터 하나씩 차례로 내려가며 catch 블럭의 괄호() 내에 선언된 참조변수의 종류와 생성된 예외클래스의 인스턴스에 instanceof 연산자를 이용해 검사하는데, 검사 결과가 true인 catch 블럭을 만날 때까지 검사가 계속됨
- 검사 결과가 true인 catch 블럭을 찾을 시 블럭에 있는 문장들을 모두 수행 후 try-catch문을 빠져나가고 예외는 처리되나, 검사 결과가 true인 catch블럭이 하나도 없으면 예외 처리 불가
- 모든 예외 클래스는 Exception클래스의 자손으로 catch 블럭의 괄호()에 Exception클래스 타입의 참조변수를 선언해놓으면 어떤 종류의 예외가 발생해도 catch블럭에 의해 처리

#### printStackTrace()와 getMessage()

- 예외 발생 시 생성되는 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보가 있으며 printStackTrace()와 getMessage()를 통해 정보 획득 가능
- catch 블럭의 괄호()에 선언된 참조변수를 통해 이 인스턴스에 접근 가능
- 이 참조변수는 선언된 catch블럭 내에서만 사용 가능

##### 자주 사용되는 메서드

- printStackTrace(): 예외 발생 당시 호출스택(Call Stack)에 있었던 메서드 정보와 예외 메시지를 화면에 출력
- getMessage(): 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있음

##### 멀티 catch블럭

- 여러 catch블럭을 | 기호를 사용해 하나의 catch블럭으로 합침
- 중복 코드 줄일 수 있음
- |로 연결할 수 있는 예외 클래스 개수에 제한 없음
- 만약 멀티 catch 블럭의 | 기호로 연결된 예외 클래스가 조상과 자손의 관계에 있다면 컴파일 에러 발생
*두 예외 클래스가 조상과 자손의 관계에 있을 시, 조상 클래스만 작성하면 되기에 불필요한 코드를 제거하라는 의미*
- 멀티 catch블럭 내에서 실제로 어떤 예외가 발생한 건지 알 수 없게 돼서, 멀티 catch 블럭에 | 기호로 연결된 예외 클래스들의 공통 분모인 조상 예외 클래스에 선언된 멤버만 사용 가능

### 1.6. 예외 발생시키기

- 키워드 throw를 사용해 프로그래머가 고의로 예외를 발생시킬 수 있음

#### 예외 발생시키기 순서

1. 연산자 new를 이용헤 발생시키려는 예외 클래스의 객체 생성
2. 키워드 throw를 이용해서 예외 발생

- RuntimeException클래스와 그 자손에 해당하는 예외는 프로그래머의 실수로 인한 발생이므로 예외처리를 강제하지 않음
- unchecked 예외: 컴파일러가 예외처리를 확인하지 않는 RuntimeException클래스
- checked 예외: 예외처리를 확인하는 Exception 클래스

### 1.7. 메서드에 예외 선언하기

- 메서드의 선언부에 키워드 throws를 사용해서 메서드 내에서 발생할 수 있는 예외를 여러 개일 경우 쉼표(,)로 구분헤 적기
- void method() throws Exception1, Exception2...{}
- 모든 예외의 최고 조상인 Exception클래스를 메서드에 선언할 시, 이 메서드는 모든 종류의 예외가 발생할 가능성이 존재한다는 뜻
- 예외 선언 시, 이 예외 뿐만 아니라 그 자손 타입의 예외도 발생하며, 오버라이딩 시 단순 선언된 예외의 갯수가 아닌 상속관계까지 고려해야함
- 메서드 선언부에 예외를 선언함으로써 메서드를 사용하려는 사람이 메서드 선언부를 볼 때, 어떤 예외들이 처리되어져야하는지 쉽게 확인 가능
- 메서드에 예외를 선언할 때 일반적으로 RuntimeException클래스들은 적지 않는데, 이 들을 메서드 선언부 throws에 선언한다고 해서 문제가 되지는 않지만, 보통 반드시 처리해줘야할 예외들만 선언
- 예외는 메서드의 throws에 명시하는 것은 예외를 처리하는 것이 아니라, 자신(예외가 발생할 가능성이 있는 메서드)을 호출한 메서드에 예외를 전달해 예외처리를 떠맡김
- 이런 식으로 계속 호출 스택에 있는 메서드들을 따라 전달되다가 제일 마지막에 있는 main 메서드에서도 예외가 처리되지 않으면, main메서드마저 종료로 프로그램이 전체 종료
- 따라서 어느 한 곳이든 반드시 try-catch문으로 예외처리해야함

### 1.8. finally블럭

- 예외의 발생 여부에 상관없이 실행되어야할 코드를 포함시킬 목적으로 사용
- try-catch문 끝에 선택적으로 덧붙여 사용되며, try-catch-finally 순서로 구성
- 이 순으로 실행되며 예외가 발생되지 않을 경우 try-finally 순으로 실행
- try 블럭의 문장을 수행하는 동안 예외의 발생여부에 관계없이 deleteTempFiles()메서드는 실행되어야하는 것
- try 블럭에서 return문이 실행되는 경우에도 finally블럭의 문장들이 먼저 실행된 후, 현재 실행 중인 메서드 종료
- 마찬가지로 catch블럭의 문장 수행 중에 return 문을 만나도 finally블럭의 문장들은 수행

### 1.9. 자동 자원 반환 - try-with-resources문

- try-catch문의 변형으로 입출력(I/O)관련 클래스 사용에 유용
- 주로 입출력에 사용되는 클래스 중 사용한 후 꼭 닫아야 사용했던 자원이 반환되는 경우가 존재
- try-with-resources문에 괄호()안에 객체를 생성하는 문장을 넣으면, 객체가 따로 해당 코드를 호출하지 않아도 try블럭을 벗어나는 순간 자동적으로 close()가 호출되며 다음에 catch블럭 혹은 finally블럭이 수행
- 이런 자동 객체의 해당 코드 호출을 원하면 클래스가 AutoCloseable라는 인터페이스를 구현한 것이여야함
- 두 예외는 동시에 발생할 수 없기에 실제 발생된 예외를 WorkException으로 하고, CloseException은 억제된 예외로 다뤄, 억제된 예외에 대한 정보는 실제 발생한 WorkException에 저장

#### Throwable에 억제된 예외와 관련된 정의된 메서드

- void addSuppressed(Throwable Exception) //억제된 예외 추가
- Throwable[] getSuppressed() //억제된 예외(배열)를 반환

- 만약 기존 try-catch문 사용 시, 먼저 발생한 WrokException은 무시되고, 마지막으로 발생한 CloseException에 대한 내용만 출력

### 1.10. 사용자정의 예외 만들기

- 기존 정의된 예외 클래스 외 필요에 따라 프로그래머가 새로운 예외 클래스를 정의해 사용 가능
- 보통 Exception클래스 또는 RuntimeException클래스로부터 상속받아 클래스를 만들지만, 필요에 따라 알맞은 예외 클래스 선택 가능
*가능하면 새로운 예외 클래스 생성보다 기존 예외 클래스 활용 추천*
- class MyException extends Exception{}
- 본인이 생성한 사용자 정의 예외 클래스도 메시지를 저장할 수 있으려면, 매개변수를 받는 생성자 추가 필요
- 기존 예외 클래스는 주로 Exception을 상속받아 checked예외로 작성하는 경우가 많았으나, 현재는 예외처리를 선택적으로 할 수 있도록 RuntimeException을 상속받아 작성하게 함
- checked예외는 반드시 예외처리를 해줘야해 예외처리가 불필요해도 try-catch문을 넣어 코드가 복잡해지기 때문
- 예외처리를 강제하는 과거 자바 환경과 달리 현재는 예외처리 여부를 선택하는 unchecked 예외를 더 선호

### 1.11. 예외 되던지기(exception re-throwing)

- 단 하나의 예외에 대해서 예외가 발생한 메서드와 호출한 메서드, 양쪽에서 처리하도록 하고 인위적으로 다시 발생시키는 방법
- 예외가 발생할 가능성이 있는 메서드에서 try-catch문을 사용해 예외를 처리해주고 catch문에서 필요한 작업을 행한 후 throw문을 사용해 예외를 다시 발생시킴
- 다시 발생한 예외는 이 메서드를 호출한 메서드에게 전달되고 호출한 메서드의 try-catch문에서 예외를 또다시 처리
- 이 방법은 하나의 예외에 대해 예외가 발생한 메서드와 이를 호출한 메서드 양쪽 모두에서 처리해줘야할 작업이 있을 때 사용
- 주의할 점: 예외가 발생할 메서드에서는 try-catch문을 사용해 예외처리를 해줌과 동시에 메서드의 선언부에 발생할 예외를 throws에 지정해야함
- 반환값이 있는 return문일 경우, catch블럭에도 return문이 존재해야하며, 예외가 발생했을 경우에도 값을 반환해야하기 때문
- 혹은 catch블럭에서 예외 되던지기를 해서 호출한 메서드로 예외를 전달할 시, return문이 없어도 되며, 검증에서도 assert문 대신 AssertError를 생성해 던짐

### 1.12. 연결된 예외(chained exception)

- 한 예외가 다른 예외를 발생 시킬 수 있음
- 예외 A가 예외 B 발생 시, A를 B의 원인 예외(cause exception)이라고 함
- initCause()로 원인 예외를 등록한 후, throw로 이 예외를 던짐

Throwable initCause(Throwable cause) // 지정한 예외를 원인 예외로 등록
Throwable getCause() // 원인 예외를 반환

#### 발생한 예외를 그대로 처리하지 않고 원인 예외로 등록해 다시 예외를 발생시키는 이유

- 여러가지 예외를 하나의 큰 분류의 예외로 묶어 다루기 위해
- 실제 발생한 예외가 어떤 것인지 알 수 없는 문제가 생기며, 예외 간 상속 관계를 변경하는 문제가 발생하기에 예외가 원인 예외를 포함할 수 있게 할 시, 두 예외가 상속관계가 아니여도 허용
- checked예외를 unchecked예외로 바꿀 수 있게 해 의미없는 try-catch문 작성이 아닌 선택적인 예외처리 가능