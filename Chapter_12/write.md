# ch12 지네릭스, 열거형, 애너테이션

## 1. 지네릭스(Generics)

### 1.1. 지네릭스란?

- 지네릭스: 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시 타입 체크(compile-time type check)를 해주는 기능
- 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어듦
- 타입 안정성을 높인다: 의도하지 않은 타입의 객체가 저장되는 것을 막고, 저장된 객체를 꺼내올 때 원래의 타입과 다른 타입으로 잘못 형변환돼 발생할 수 있는 오류를 줄여줌
- ArrayList 같은 컬렉션 클래스는 다양한 종류의 객체를 담을 수 있지만, 꺼낼때마다 타입체크를 할 경우 번거로운데다 원하지 않는 종류의 객체가 포함돼도 막을 수 없기에 지네릭스가 해결

#### 지네릭스의 장점

1. 타입 안정성을 제공
2. 타입 체크와 형변환을 생략할 수 있으므로 코드가 간결

### 1.2. 지네릭 클래스의 선언

- 지네릭 타입은 클래스와 메서드에 선언할 수 있음
- 클래스에 선언하는 지네릭 타입은 클래스 옆에 <T>를 붙이고 해당 Object를 모두 T로 바꿈
- T: 타입 변수(type variable)로 다른 것을 사용해도 되며 상황에 맞게 의미있는 문자를 채택해 사용
- 타입 변수가 여러 개인 경우 콤마(,)를 구분자로 나열
- 기호의 종류만 다를 뿐 임의의 참조현 타입을 의미함
- 기존에는 다양한 종류의 타입을 다루는 메서드의 매개변수나 리턴타입으로 Object타입의 참조변수를 많이 사용했어서 형변환이 불가피했으나 Object 대신 원하는 타입을 지정
- 지네릭 클래스지만 이전 방식으로 객체를 생성하는 것은 허용되나, 지네릭 타입을 지정하지 않아 안전하지 않다는 경고 발생

#### 지네릭스의 용어

- class Box<T>{}
- Box<T>: 지네릭 클래스로 T의 Box 혹은 T Box로 읽음
- T: 타입 변수 또는 타입 매개변수.(T는 타입 문자)
- Box: 원시 타입(raw type)

- 타입 문자 T는 타입 변수/타입 매개변수로 불리며, 이는 메서드 매개변수와 유사한 면이 존재해 그렇게 불림
- 지네릭 타입 호출: 타입 매개변수에 타입을 지정하는 것
- 매개변수화된 타입(parameterized type): 지정된 타입 String으로, 교재에서는 대입된 타입이라는 명칭으로 사용
- 지네릭 클래스는 서로 다른 타입을 대입해 호출할 수 있지만 이 둘이 별개의 클래스를 의미하는 것은 아님
- 컴파일 후 Box<>는 원시타입인 Box로 바뀌며, 지네릭 타입이 제거됨

#### 지네릭스 제한

- 지네릭 클래스 Box의 객체를 생성할 때 객체 별로 다른 타입을 지정하는 것은 인스턴스 별로 다르게 동작하도록 의도한 기능
- 모든 객체에 대해 동일하게 동작해야하는 static 멤버에 타입 변수 T를 사용할 수 없음
=> T는 인스턴스 변수로 간주되기 때문이며, static 멤버는 인스턴스 변수 참조 불가
=> static 멤버는 타입 변수에 지정된 타입, 즉 대입된 타입의 종류에 관계없이 동일해야하기 때문
- 지네릭 타입의 배열을 생성하는 것도 허용 불가
- 지네릭 배열 타입의 참조변수를 선언하는 것은 가능하나, 배열을 생성할 수는 없음
- 지네릭 배열 생성 불가 이유는 new 연산자로, 이 연산자는 컴파일 시점에 타입 T가 뭔지 정확하게 알아야함
- T가 어떤 타입이 될지 전혀 알수 없기에 사용 불가. instanceof() 연산자도 마찬가지
- 지네릭 배열을 생성해야할 필요가 있을 시, new 연산자 대신 Reflection API의 newInstance()같은 동적으로 객체를 생성하는 메서드로 배열을 생성하거나, Object 배열을 생성해 복사한 다음 T[]로 형변환하는 방법이 존재

### 1.3. 지네릭 클래스의 객체 생성과 사용

- 지네릭 클래스를 사용할 때, 참조 변수와 생성자에 대입된 타입이 일치해야하며, 불일치 시 에러 발생
- 두 지네릭 클래스의 타입이 상속관계에 있고, 대입된 타입이 같은 것은 가능
- 추정이 가능할 경우 타입 생략 가능
- 생성된 객체에 타 객체를 추가 시, 대입된 타입과 다른 타입의 객체는 추가 불가

### 1.4. 제한된 지네릭 클래스

- 타입 문자로 사용할 타입을 명시할 시 한 종류의 타입만 저장할 수 있도록 제한이 가능하나, 여전히 모든 종류의 타입 지정은 가능
- 타입 매개변수 T에 지정할 수 있는 타입의 종류를 제한할 수 있는 방법: extends를 사용해 특정 타입의 자손들만 대입하도록 제한
=> 여전히 한 종류의 타입만 담을 수 있으나 Fruit 클래스의 자손들만 담도록 제한
- 다형성에서 조상 타입의 참조변수로 자손 타입의 객체를 가리킬 수 있는 것처럼, 매개변수화된 타입의 자손 타입도 가능
- 타입 매개변수 T에 Object를 대입 시, 모든 종류의 객체 저장 가능
- 클래스가 아닌 인터페이스를 구현해야할 경우, extends 사용(implements 사용 X)
- 클래스 자손이며 인터페이스 구현이 필요할 경우, & 기호로 연결

### 1.5. 와일드 카드

- 지네릭 타입을 오버로딩 시 컴파일 에러가 발생하는데, 이는 지네릭 타입이 다른 것만으로는 오버로딩이 성립되지 않기 때문
- 지네릭 타입은 컴파일러가 컴파일할 때만 사용하고 제거되기에 중복된 메서드는 오버로딩이 아닌 메서드 중복 정의
=> 이럴 때 사용하기 위해 와일드 카드 고안으로, 기호는 ?로 표현하며 어떤 타입이든 사용이 가능
- ? 만으로는 Object 타입과 다를게 없으므로 extends와 super로 상한과 하한을 제한

- <? extends T>: 와일드 카드의 상한 제한, T와 그 자손들만 가능
- <? super T>: 와일드 카드의 하한 제한. T와 그 조상들만 가능
- <?>: 제한이 없으며 모든 타입이 가능 <? extends Object>와 통일

- <?>를 사용 시 모든 종류의 해당 지정한 객체를 메서드의 매개변수로 가능하지만 전과 달리 box의 요소가 Fruit의 자손이라는 보장이 없어 box에 저장된 요소를 Fruit타입의 참조변수로 못 받음
- 실제 테스트 시 문제 없이 컴파일되나 지네릭 클래스 FruitBox를 제한하기 때문
=> 컴파일러는 모든 FruitBox의 요소들이 Fruit의 자손이라는 것을 알기 때문

- static 옆에 있는 <T>는 메서드에 선언된 지네릭 타입으로 지네릭 메서드라고 칭함

### 1.6. 지네릭 메서드

- 지네릭 메서드: 메서드 선언부에 지네릭 타입이 선언된 메서드
- Collections.sort()가 예시, 지네릭 타입의 선언 위치는 반환 타입 바로 앞
- 지네릭 클래스에 정의된 타입 매개변수와 지네릭 메서드에 정의도ㅓㅣㄴ 타입 매개변수는 전혀 별개의 것으로 같은 문자를 사용해도 같은 것이 아님
- static 멤버에는 타입 매개변수를 사용할 수 없지만, 메서드에 지네릭 타입을 선언하고 사용하는 것은 가능
- 메서드에 선언된 지네릭 타입은 지역 변수를 선언한 것과 같다고 간주
- 이 타입 매개변수는 메서드 내에서만 지역적으로 사용될 것이므로 메서드가 static이던 아니던 상관없음
*같은 이유로 내부 클래스에 선언된 타입 문자가 외부 클래스의 타입 문자와 같아도 구별 가능*
- 대부분의 경우 컴파일러가 타입을 추정할 수 있기에 생략 가능
- 지네릭 메서드를 호출 시 대입된 타입을 생략할 수 없는 경우 참조변수나 클래스 이름 생략 불가
- 같은 클래스 내 멤버들끼리는 참조변수나 클래스 이름에 this나 클래스이름.을 생략하고 메서드 이름만으로 호출이 가능하나, 대입된 타입이 있을 경우 반드시 작성해야하며, 기술적인 이유에 의한 규칙으로 지켜야함
- 지네릭 메서드는 매개변수의 타입이 복잡할 때 유용하며 타입을 별도로 선언함으로써 코드 간략화 가능

### 1.7. 지네릭 타입의 형변환

- 지네릭 타입과 넌지네릭(non_generic)간의 형변환은 항상 가능하나 경고가 발생
- 대입된 타입이 다른 지네릭 타입 간에는 형변환이 불가능. Object여도 불가능
- Object를 상속받은 지네릭 타입은 가능
- 반대의 형변환도 성립되나 확인되지 않는 형변환이라고 경고
- <?>에서 <T>로 형변환은 가능하나 <Object>는 불가능: 와일드 카드가 포함된 지네릭 타입으로 형변환하면 가능
- 와일드 카드가 사용된 지네릭 타입끼리도 형변환이 가능하나 와일드 카드는 확정된 타입이 아니므로 컴파일러는 미확정 타입으로 형변환하는 것이라고 경고함

### 1.8. 지네릭 타입의 제거

- 컴파일러는 지네릭 타입을 이용해 소스파일을 체크하고, 필요한 곳에 형변환을 넣어주며 지네릭 타입을 제거
=> 컴파일된 파일(*.class)에는 지네릭 타입에 대한 정보가 없음
- 이러한 이유는 지네릭이 도입되기 이전 소스 코드와의 호환성을 유지. 아직도 원시입을 사용해 코드 작성을 허용

#### 지네릭 타입 제거 과정

- 지네릭 타입의 경계(bound) 제거: 지네릭 타입이 <T extends Fruit>면 T는 Fruit로 치환되며 클래스 옆 선언은 제거
- 지네릭 타입 제거 후 타입 불일치 시, 형변환 추가: 와일드 카드가 포함된 경우 적절한 타입으로의 형변환이 추가

## 2. 열거형(enums)

### 2.1. 열거형이란?

- 서로 관련된 상수를 편리하게 선언하기 위한 것으로 여러 상수를 정의할 때 사용 시 유용
- 열거형이 갖는 값 뿐만 아니라 타입도 관리해 보다 논리적인 오류를 줄여줌
- 기존 많은 언어들은 타입이 달라도 값이 같으면 조건식 결과가 참이나 자바의 열거형은 타입에 안전한 열거형(typesafe enum)이라서 실제 값이 같아도 타입이 다르면 컴파일 에러 발생
- 상수의 값이 바뀌면, 해당 상수를 참조하는 모든 소스를 다시 컴파일해야하나 열거형 상수를 사용 시, 기존 소스를 다시 컴파일 하지 않아도됨

### 2.2. 열거형의 정의와 사용

- 열거형 정의 방법: enum 열거형 이름[]
- 괄호[] 안에 상수의 이름 나열
- 열거형에 정의된 상수를 사용하는 방법: 열거형이름.상수명
- 클래스의 static 변수를 참조하는 것과 동일
- 열거형 상수간 비교에는 '=='를 사용. equals()가 아닌 ==으로 비교가 가능한 것은 그만큼 빠른 성능을 제공
- <, >같은 비교 연산자는 사용할 수 없고 compareTo()는 사용이 가능하며, 두 비교대상이 같으면 0, 왼쪽이 크면 양수, 오른쪽이 크면 음수를 반환
- 주의할 점: case문에 열거형의 이름은 적지 않고 상수의 이름만 적어야한다는 제약
=> 오타를 줄이고 간결

#### 모든 열거형의 조상 - java.lang.Enum

- values(): 열거형의 모든 상수를 배열에 담아 반환하며 모든 열거형이 가지고 있는 것으로 컴파일러가 자동으로 추가
- ordinal(): 모든 열거형의 조상인 java.lang.Enum 클래스에 정의된 것으로, 열거형 상수가 정의된 순서(0부터 시작)를 정수로 반환
- valueOf(): 컴파일러가 자동으로 추가해주는 메서드가 있으며, 열거형 상수의 이름으로 문자열 상수에 대한 참조를 얻을 수 있게함

### 2.3. 열거형에 멤버 추가하기

- Enum클래스에 정의된 ordinal()이 열거형 상수가 정의된 순서를 반환하나, 이 값을 열거형 상수의 값으로 사용하지 않는 것이 좋음: 이 값은 내부적인 용도로만 사용되기 위한 것이기 때문
- 열거형 상수의 값이 불연속적인 경우 열거형 상수의 이름 옆에 원하는 값을 괄호와 함께 적어주고 지정된 값을 저장할 수 있는 인스턴스 변수와 생성자를 새로 추가해야함
- 주의할 점: 먼저 열거형 상수를 모두 정의한 다음 다른 멤버들을 추가해야하며 열거형 상수의 마지막에 ;을 붙여야함
- 열거형의 인스턴스 변수는 반드시 final이어야한다는 제약은 없지만, value는 열거형 상수의 값을 저장하기 위한 것으로 final을 붙임

#### 열거형에 추상 메서드 추가하기

### 2.4. 열거형의 이해

- 열거형 상수 하나하나가 Direction객체
- 열거형 상수는 바뀌지 않는 값으로 '=='로 비교가 가능
- 모든 열거형은 추상 클래스 Enum의 자손
- 객체가 생성될 때마다 번호를 붙여 인스턴스 변수 ordinal에 저장
- Camparable인터페이스를 구현해 열거형 상수간의 비교가 가능하도록 되어있음
- 추상 메서드를 새로 추가하면, 클래스 앞에도 abstract를 붙여야하며 각 static상수들도 추상 메서드를 구현해줘야함

## 3. 애너테이션(annotation)

### 3.1. 애너테이션이란?

- 소스코드의 주석에 소스코드에 대한 정보를 저장하고, 소스코드의 주석으로부터 HTML문서를 생성하는 프로그램(javadoc.exe)을 만들어 사용
- @이 붙은 미리 정의된 태그들을 이용해 주석 안에 정보를 저장하고, javadoc.exe라는 프로그램이 이 정보를 읽어 문서를 작성하는데 사용
- 애너테이션: 프로그램의 소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것
- 에너테이션은 주석(comment)처럼 프로그래밍 언어에 영향을 미치지 않으면서도 타 프로그램에게 유용한 정보를 제공할 수 있다는 장점이 존재
- 자신이 작성한 소스코드 중 특정 메서드만 테스트하길 원하면 @Test만 메서드 앞에 붙여 사용하며, 이 메서드를 테스트해야한다는 것을 테스트 프로그램에게 알릴 뿐, 메서드가 포함된 프로그램 자체에서는 아무런 영향을 미치지 않으며 주석처럼 존재
- 모든 프로그램에게 의미가 있는 것은 아니고 해당 프로그램에 미리 정의된 종류와 형식으로 작성해야하만 의미가 있음(미리 정의된 종류와 형식으로 작성)
- JDK에서 제공하는 표준 애너테이션은 주로 컴파일러를 위한 것으로 컴파일러에게 유용한 정보를 제공

### 3.2. 표준 애너테이션

#### @Override

- 메서드 앞에만 붙일 수 있는 애너테이션으로, 조상 메서드를 오버라이딩하는 것이라는 것을 컴파일러에게 알려주는 역할
- 오버라이딩할 때 조상 메서드의 이름을 잘못 써도 컴파일러는 잘못된 것인지 모르는데, 새로운 이름의 메서드가 추가된 것으로 인식하며 실행 시에도 오류가 발생하지 않고 조상의 메서드가 호출되므로 잘못됭 부분을 찾기 어려움
- @Override를 붙이면 컴파일러가 같은 이름의 메서드가 조상에 있는지 확인하고 없으면 에러 메시지 출력
- 필수는 아니고 실수를 미연에 방지

#### @Deprecated

- 더 이상 사용되지 않는 필드나 메서드에 붙이는 것으로 붙여진 대상은 다른 것으로 대체되었으니 더 이상 사용하지 않을 것을 권장한다는 의미
- @Deprecated 사용 시 컴파일 때 메시지가 발생

#### @FunctionalInterface

- 함수형 인터페이스로 붙여지면 컴파일러가 함수형 인터페이스를 올바르게 선언했는지 확인하고, 잘못된 경우 에러 발생
- 필수는 아니며 붙이면 실수 방지 가능

#### @SuppressWarnings

- 컴파일러가 보여주는 경고메시지가 나타나지 않게 억제
- 억제 가능 경고 메시지 종류는 여러가지가 존재
- deprecation: @Deprecated가 붙은 대상을 사용해서 발생하는 경고
- unchecked: 지네릭스로 타입을 지정하지 않았을 때 발생하는 경고
- rawTypes: 지네릭스를 사용하지 않아서 발생하는 경고
- varargs: 가변인자의 타입이 지네릭 타입일 때 발생하는 경고
*위의 경고를 억제할 때 사용하며, 방법은 애너테이션 뒤에 괄호()안에 문자열로 지정*
- 둘 이상의 경고를 동시에 억제하려면 배열처럼 괄호{}를 추가로 사용: 나중에 추가된 코드에서 발생할 수도 있는 경고까지 억제될 수 있으므로 바람직하지 않으며, 해당 대상에만 애너테이션을 붙여 경고의 억제범위를 최소화

#### @SafeVarargs

- 메서드에 선언된 가변인자 타입이 non-reifiable타입일 경우, 해당 메서드를 선언하는 부분과 호출하는 부분에서 unchecked 경고가 발생. 이 코드에 문제가 없을 시 경고를 억제하기 위해 사용
- static / final이 붙은 메서드와 생성자에만 붙일 수 있음 => 오버라이딩 가능할 메서드에서는 사용 불가
- 지네릭스에 본 것처럼 어떤 타입들은 컴파일 이후에 제거되는데, 컴파일 후에 제거되지 않는 타입을 reifiable 타입이라 하고, 제거되는 타입을 non-reifiable이라고 함
- 지네릭 타입은 대부분 컴파일 시에 제거되므로 non-reifiable 타입임
- 메서드를 선언할 때 @SafeVarargs를 붙여 이 메서드의 가변인자는 타입 안정성이 있다고 컴파일러에게 알려 경고가 발생하지 않게 해야함
- @SuppressWarnings("unchecked")로 경고 억제 시, 메서드 선언 뿐만 아니라 메서드가 호출되는 곳에더 애너테이션을 붙여야함
- @SafeVarargs로 unchecked 경고는 억제할 수 있지만, varargs 경고는 억제할 수 없기에 이 두 애너테이션을 같이 붙이면 됨
- @SuppressWarnings("varargs")를 붙이지 않아도 경고 없이 컴파일이 되지만 -Xlint옵션을 붙여 컴파일 시 varargs 경고가 발생하는 것을 확인 가능해, 가능하면 두 애너테이션을 항상 같이 사용하는 것을 권장

### 3.3. 메타 애너테이션

- 애너테이션을 위한 애너테이션으로 애너테이션을 정의할 때 애너테이션의 적용대상이나 유지기간 등을 지정하는데 사용

#### @Target

- 애너테이션이 적용가능한 대상을 지정하는데 사용
- 여러 개의 값을 지정할 때는 배열에서처럼 괄호{} 사용
- TYPE: 타입 선언 시, 애너테이션을 붙일 수 있다는 뜻
- TYPE_USE: 해당 타입의 변수를 선언할 때 붙일 수 있다는 뜻

#### @Retention

- 애너테이션이 유지되는 기간을 지정하는데 사용
- @Override나 @SuppressWarnings 처럼 컴파일러가 사용하는 애너테이션은 유지 정책이 SOURCE로 컴파일러를 직접 작성할 것이 아니면, 이 유지정책은 필요없음
- 유지 정책을 RUNTIME으로 하면, 실행 시 리플렉션을 통해 클래스 파일에 저장된 애너테이션의 정보를 읽어 처리 가능
- FunctionInterface는 @override처럼 컴파일러가 체크해주는 애너티이션이지만, 실행 시에도 사용되므로 유지 정책이 RUNTIME으로 되어있음
- 유지 정책 CLASS: 컴파일러가 애너테이션의 정보를 클래스 파일에 저장할 수 있게 하지만, 클래스 파일이 JVM에 로딩될 때 애너테이션의 정보가 무시돼 실행 시 애너테이션에 대한 정보를 얻을 수 없음. 그렇기에 CLASS가 유지정책의 기본값임에도 불구하고 잘 사용하지 않는 이유
*지역 변수에 붙은 애너테이션은 컴파일러만 인식할 수 있으므로, 유지정책이 RUNTIME인 애너테이션을 지역변수에 붙여도 실행 시 인식되지 않음*

#### @Ducnmented

- 애너테이션에 대한 정보가 javadoc으로 작성된 문서에 포함되도록 하게함
- 자바에서 제공하는 기본 애너테이션 중 @Override, @SuppressWarinigs를 제외하고는 모드 메타 애너테이션이 붙여있음

#### @Inherited

- 애너테이션이 자손 클래스에 상속되도록 함
- 이 애너테이션이 붙인 애너테이션을 조상 클래스에 붙이면, 자손 클래스도 이 애너테이션이 붙은 것과 같이 인식

#### @Repeatable

- 보통 하나의 대상에 한 종류의 애너테이션을 붙이는데, 이 애너테이션이 붙인 애너테이션은 여러 번 붙이기 가능
- 일반적인 애너테이션과 달리 같은 이름의 애너테이션이 여러 개가 하나의 대상에 적용될 수 있기에, 이 애너테이션들을 하나로 묶어 다룰 수 있는 애너테이션도 추가로 정의 필요

#### @Native

- 네이티브 메서드(native method)에 의해 참조되는 상수 필드에 붙이는 애너테이션
- 네이티브 메서드: JVM이 설치된 OS메서드
- 네이티브 메서드는 보통 C언어로 작성되어 있는데, 자바에서는 메서드의 선언부만 정의하고 구현은 하지 않음 => 추상 메서드처럼 선언부만 있고 몸통이 없음
- 모든 클래스의 조상인 Object클래스의 메서드들은 대부분 네이티브 메서드
- 네이티브 메서드는 자바로 정의되어 있기에 호출 방법은 자바의 일반 메서드와 다르지 않지만 실제로 호출되는 것은 OS의 메서드
- 아무런 내용도 없는 네이티브 메서드를 선언해놓고 호출한다고 되는 건 아니고 자바에 정의된 네이티브 메서드와 OS의 메서드를 연결해주는 작업이 추가로 필요
- 이는 JNI가 역할 수행

### 3.4. 애너테이션 타입 정의하기

- 새로운 애너테이션을 정의하는 방법: @ 기호를 붙이는 것을 제외하면 인터페이스를 정의하는 것과 동일
- @Override는 애너테이션이고 Ovveride는 애너테이션의 타입

#### 애너테이션의 요소

- 애너테이션의 요소: 애너테이션 내 선언된 메서드
*애너테이션에도 인터페이스처럼 상수를 정의할 수 있지만, 디폴트 메서드는 정의 불가*
- 애너테이션의 요소는 반환값이 있고 매개변수는 없는 추상 메서드의 형태를 가지며, 상속을 통해 구현하지 않아도됨
- 다만, 애너테이션을 적용할 때, 이 요소들의 값을 빠짐없이 지정해줘야하며, 요소 이름도 같이 적어주므로 순서는 상관없음
- 애너테이션의 각 요소는 기본값을 가질 수 있으며, 기본값이 있는 요소는 애너테이션을 적용할 때 값을 지정하지 않으면 기본값이 사용
*기본값으로 null을 제외한 모든 리터럴이 가능*
- 애너테이션 요소가 오직 하나 뿐이고 이름이 value일 경우, 애너테이션을 적용할 때 요소의 이름을 생략하고 값만 적어도됨
- 요소 타입이 배열인 경우, 괄호{}를 사용해 여러 개의 값 지정 가능
- 기본값 지정할 때도 마찬가지로 괄호{}를 사용
- 요소 타입이 배열이 ㄹ때도 요소 이름이 value이면, 요소의 이름 생략 가능

#### java.lang.annotation.Annotation

- 모든 애너테이션 조상: Annotation
- 애너테이션은 상속을 허용하지 않아 명시적으로 Annotation을 조상으로 지정 불가
- 또한 애너테이션이 아닌 일반적인 인터페이스로 정의
- 모든 애너테이션의 조상인 Annotation인터페이스가 정의되어 있기에 모든 애너테이션 객체에 대해 equals(), hashCode(), toString()과 같은 메서드를 호출하는 것이 가능

#### 마커 애너테이션 Marker Annotation

- 값을 지정할 필요가 없는 경우, 애너테이션의 요소를 하나도 정의하지 않을 수 있음
- 마커 애너테이션: Serializable이나 Cloneable 인터페이스처럼, 요소가 하나도 정의되지 않은 애너테이션

#### 애너테이션 요소의 규칙

1. 요소의 타입은 기본형, String, enum, 애너테이션, Class만 허용
2. () 안에 매개변수 선언 불가
3. 예외 선언 불가
4. 요소를 타입 매개변수로 정의 불가

- AnnotationEx5.class: 클래스 객체를 의미하는 리터럴
- 클래스 객체: 모든 클래스 파일은 클래스 로더(Classloader)에 의해 메모리에 올라갈 때, 클래스에 대한 정보가 담긴 객체를 생성
- 이 객체를 참조 시 클래스 이름.class 형식 사용
- 클래스 객체에는 해당 클래스에 대한 모든 정보를 가지고 있는데 애너테이션의 정보도 포함
- 클래스 객체가 가지고 있는 getAnnotation()이라는 메서드에 매개변수로 정보를 얻고자하는 애너테이션을 지정해주거나 getAnnotations()로 모든 애너테이션모든 애너테이션을 배열로 받아 가져올 수 있음