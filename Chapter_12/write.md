# ch12 지네릭스, 열거형, 애너테이션

## 1. 지네릭스(Generics)

### 1.1. 지네릭스란?

- 지네릭스: 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시 타입 체크(compile-time type check)를 해주는 기능
- 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어듦
- 타입 안정성을 높인다: 의도하지 않은 타입의 객체가 저장되는 것을 막고, 저장된 객체를 꺼내올 때 원래의 타입과 다른 타입으로 잘못 형변환돼 발생할 수 있는 오류를 줄여줌
- ArrayList 같은 컬렉션 클래스는 다양한 종류의 객체를 담을 수 있지만, 꺼낼때마다 타입체크를 할 경우 번거로운데다 원하지 않는 종류의 객체가 포함돼도 막을 수 없기에 지네릭스가 해결

#### 지네릭스의 장점

1. 타입 안정성을 제공
2. 타입 체크와 형변환을 생략할 수 있으므로 코드가 간결

### 1.2. 지네릭 클래스의 선언

- 지네릭 타입은 클래스와 메서드에 선언할 수 있음
- 클래스에 선언하는 지네릭 타입은 클래스 옆에 <T>를 붙이고 해당 Object를 모두 T로 바꿈
- T: 타입 변수(type variable)로 다른 것을 사용해도 되며 상황에 맞게 의미있는 문자를 채택해 사용
- 타입 변수가 여러 개인 경우 콤마(,)를 구분자로 나열
- 기호의 종류만 다를 뿐 임의의 참조현 타입을 의미함
- 기존에는 다양한 종류의 타입을 다루는 메서드의 매개변수나 리턴타입으로 Object타입의 참조변수를 많이 사용했어서 형변환이 불가피했으나 Object 대신 원하는 타입을 지정
- 지네릭 클래스지만 이전 방식으로 객체를 생성하는 것은 허용되나, 지네릭 타입을 지정하지 않아 안전하지 않다는 경고 발생

#### 지네릭스의 용어

- class Box<T>{}
- Box<T>: 지네릭 클래스로 T의 Box 혹은 T Box로 읽음
- T: 타입 변수 또는 타입 매개변수.(T는 타입 문자)
- Box: 원시 타입(raw type)

- 타입 문자 T는 타입 변수/타입 매개변수로 불리며, 이는 메서드 매개변수와 유사한 면이 존재해 그렇게 불림
- 지네릭 타입 호출: 타입 매개변수에 타입을 지정하는 것
- 매개변수화된 타입(parameterized type): 지정된 타입 String으로, 교재에서는 대입된 타입이라는 명칭으로 사용
- 지네릭 클래스는 서로 다른 타입을 대입해 호출할 수 있지만 이 둘이 별개의 클래스를 의미하는 것은 아님
- 컴파일 후 Box<>는 원시타입인 Box로 바뀌며, 지네릭 타입이 제거됨

#### 지네릭스 제한

- 지네릭 클래스 Box의 객체를 생성할 때 객체 별로 다른 타입을 지정하는 것은 인스턴스 별로 다르게 동작하도록 의도한 기능
- 모든 객체에 대해 동일하게 동작해야하는 static 멤버에 타입 변수 T를 사용할 수 없음
=> T는 인스턴스 변수로 간주되기 때문이며, static 멤버는 인스턴스 변수 참조 불가
=> static 멤버는 타입 변수에 지정된 타입, 즉 대입된 타입의 종류에 관계없이 동일해야하기 때문
- 지네릭 타입의 배열을 생성하는 것도 허용 불가
- 지네릭 배열 타입의 참조변수를 선언하는 것은 가능하나, 배열을 생성할 수는 없음
- 지네릭 배열 생성 불가 이유는 new 연산자로, 이 연산자는 컴파일 시점에 타입 T가 뭔지 정확하게 알아야함
- T가 어떤 타입이 될지 전혀 알수 없기에 사용 불가. instanceof() 연산자도 마찬가지
- 지네릭 배열을 생성해야할 필요가 있을 시, new 연산자 대신 Reflection API의 newInstance()같은 동적으로 객체를 생성하는 메서드로 배열을 생성하거나, Object 배열을 생성해 복사한 다음 T[]로 형변환하는 방법이 존재

### 1.3. 지네릭 클래스의 객체 생성과 사용

- 지네릭 클래스를 사용할 때, 참조 변수와 생성자에 대입된 타입이 일치해야하며, 불일치 시 에러 발생
- 두 지네릭 클래스의 타입이 상속관계에 있고, 대입된 타입이 같은 것은 가능
- 추정이 가능할 경우 타입 생략 가능
- 생성된 객체에 타 객체를 추가 시, 대입된 타입과 다른 타입의 객체는 추가 불가

### 1.4. 제한된 지네릭 클래스

- 타입 문자로 사용할 타입을 명시할 시 한 종류의 타입만 저장할 수 있도록 제한이 가능하나, 여전히 모든 종류의 타입 지정은 가능
- 타입 매개변수 T에 지정할 수 있는 타입의 종류를 제한할 수 있는 방법: extends를 사용해 특정 타입의 자손들만 대입하도록 제한
=> 여전히 한 종류의 타입만 담을 수 있으나 Fruit 클래스의 자손들만 담도록 제한
- 다형성에서 조상 타입의 참조변수로 자손 타입의 객체를 가리킬 수 있는 것처럼, 매개변수화된 타입의 자손 타입도 가능
- 타입 매개변수 T에 Object를 대입 시, 모든 종류의 객체 저장 가능
- 클래스가 아닌 인터페이스를 구현해야할 경우, extends 사용(implements 사용 X)
- 클래스 자손이며 인터페이스 구현이 필요할 경우, & 기호로 연결

### 1.5. 와일드 카드

- 지네릭 타입을 오버로딩 시 컴파일 에러가 발생하는데, 이는 지네릭 타입이 다른 것만으로는 오버로딩이 성립되지 않기 때문
- 지네릭 타입은 컴파일러가 컴파일할 때만 사용하고 제거되기에 중복된 메서드는 오버로딩이 아닌 메서드 중복 정의
=> 이럴 때 사용하기 위해 와일드 카드 고안으로, 기호는 ?로 표현하며 어떤 타입이든 사용이 가능
- ? 만으로는 Object 타입과 다를게 없으므로 extends와 super로 상한과 하한을 제한

- <? extends T>: 와일드 카드의 상한 제한, T와 그 자손들만 가능
- <? super T>: 와일드 카드의 하한 제한. T와 그 조상들만 가능
- <?>: 제한이 없으며 모든 타입이 가능 <? extends Object>와 통일

- <?>를 사용 시 모든 종류의 해당 지정한 객체를 메서드의 매개변수로 가능하지만 전과 달리 box의 요소가 Fruit의 자손이라는 보장이 없어 box에 저장된 요소를 Fruit타입의 참조변수로 못 받음
- 실제 테스트 시 문제 없이 컴파일되나 지네릭 클래스 FruitBox를 제한하기 때문
=> 컴파일러는 모든 FruitBox의 요소들이 Fruit의 자손이라는 것을 알기 때문

- static 옆에 있는 <T>는 메서드에 선언된 지네릭 타입으로 지네릭 메서드라고 칭함

### 1.6. 지네릭 메서드

- 지네릭 메서드: 메서드 선언부에 지네릭 타입이 선언된 메서드
- Collections.sort()가 예시, 지네릭 타입의 선언 위치는 반환 타입 바로 앞
- 지네릭 클래스에 정의된 타입 매개변수와 지네릭 메서드에 정의도ㅓㅣㄴ 타입 매개변수는 전혀 별개의 것으로 같은 문자를 사용해도 같은 것이 아님
- static 멤버에는 타입 매개변수를 사용할 수 없지만, 메서드에 지네릭 타입을 선언하고 사용하는 것은 가능
- 메서드에 선언된 지네릭 타입은 지역 변수를 선언한 것과 같다고 간주
- 이 타입 매개변수는 메서드 내에서만 지역적으로 사용될 것이므로 메서드가 static이던 아니던 상관없음
*같은 이유로 내부 클래스에 선언된 타입 문자가 외부 클래스의 타입 문자와 같아도 구별 가능*
- 대부분의 경우 컴파일러가 타입을 추정할 수 있기에 생략 가능
- 지네릭 메서드를 호출 시 대입된 타입을 생략할 수 없는 경우 참조변수나 클래스 이름 생략 불가
- 같은 클래스 내 멤버들끼리는 참조변수나 클래스 이름에 this나 클래스이름.을 생략하고 메서드 이름만으로 호출이 가능하나, 대입된 타입이 있을 경우 반드시 작성해야하며, 기술적인 이유에 의한 규칙으로 지켜야함
- 지네릭 메서드는 매개변수의 타입이 복잡할 때 유용하며 타입을 별도로 선언함으로써 코드 간략화 가능

### 1.7. 지네릭 타입의 형변환

- 