# ch7 객체지향 프로그래밍2

***

## 1. 상속(ingeritance)

===

### 1.1. 상속의 정의와 장점

**상속**: 기존의 클래스를 재사용해 새로운 클래스를 작성하는 것

#### 상속을 사용해 클래스 작성 이점

- 적은 양의 코드로 새로운 클래스 작성
- 코드를 공통적으로 관리해 코드의 추가 및 변경 용이

#### 특징: 코드의 재사용성을 높이고 코드의 중복을 제거해 프로그램의 생산성과 유지보수에 크게 기여

자바에서 상속을 구현하는 방법: 새로 작성하고자 하는 클래스의 이름 뒤에 상속자 하는 클래스의 이름을 extends와 함께 작성
*예: class Child extends Parent{ }*

**조상 클래스**: 상속해주는 클래스(부모(parent) 클래스, 상위(super) 클래스, 기반(base) 클래스)
**자손 클래스**: 상속 받는 클래스(자식(child)클래스, 하위(sub)클래스, 파생된(dervied) 클래스)

**상속계층도(class hierarchy)**: 클래스 간의 상속관계를 그림으로 표현한 것

Parent 클래스에 특정 정수형 변수를 멤버변수로 추가하면, 자손 클래스는 조상의 멤버를 모두 상속받음.
=> 반대로 자손 클래스에 특정 변수를 선언해도 조상 클래스에는 영향이 없음

상속을 받는다는 것: 조상클래스를 확장(extend)한다는 의미

- 생성자와 초기화 블럭은 상속되지 않으며, 멤버만 상속
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많음
*접근 제어자(access modifier)가 private/default인 멤버들은 상속되지 않는다기보다 상속은 받으나 자손 클래스로부터 접근이 제한되는 것*

만약 부모 parent 클래스에서 자식 클래스 child1, child2를 생성하면 두 클래스 모두 부모 parent 클래스를 상속받지만 자식 클래스는 서로 아무런 관계가 성립되지 않음
=> 자식 클래스에 공통적으로 추가되어야 하는 멤버(멤버변수나 메서드)가 있을 시, 두 클래스에 따로 추가하는 것보다 부모 클래스에 추가하는 것을 권장
==> parent 클래스 하나만 변경하면 돼서 작업이 간단해지며, 같은 내용의 코드를 한 곳에서 관리해 코드 중복을 줄임.
*코드 중복이 많아질수록 유지보수가 어려워지고 일관성 유지가 어려워짐*

- 같은 내용의 코드를 하나 이상의 클래스에 중복적으로 추가해야하는 경우, 상속 관계를 이용해 코드의 중복을 최소화해야함.
- 만약 child1 밑에 grandchild 클래스 생성시, child1은 부모 클래스, parent는 간접 조상으로 간접적인 상속관계로 구성.

#### 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성돼 따로 조상 클래스의 인스턴스를 생성하지 않고도 조상 클래스 멤버 사용 가능

======

### 1.2. 클래스간의 관계 - 포함관계

- 클래스 재사용 방법: 상속 외 클래스 간 포함 관계를 맺는 것
- 클래스 간의 포함관계를 맺어주는 것: 한 클래스의 멤버변수로 타 클래스 타입의 참조변수를 선언하는 것
*하나의 거대한 클래스를 작성하는 것보다 단위별로 여러 개의 클래스를 작성한 다음, 이 단위 클래스들을 포함관계로 재사용시 보다 간결하고 손쉽게 클래스를 작성할 수 있으며, 작성된 단위 클래스들은 다른 클래스를 작성하는데 재사용이 가능*
=> 포함관계 사용 시 클래스 작성이 쉽고 코드가 간결해 이해가기 쉬우며 단위 클래스 별로 코드가 작게 나뉘어 작성되기 때문에 코드 관리에 용이

### 1.3. 클래스간의 관계 결정하기

클래스를 가지고 문장을 만들 때 ~은 ~이다. 라는 문장 성립 시 서로 상속관계를 맺어주고, ~은 ~을 가지고 있다. 문장이 성립 시 포함관계를 가짐

- 상속 관계: ~은 ~이다(is -a)
- 포함 관계: ~은 ~을 가지고 있다(has -a)
*프로그램의 모든 클래스로 분석해 가능한 많은 관계를 맺도록 노력해 코드의 재사용성을 높여야함*

### 1.4. 단일 상속(single ingeritance)

- C++에서는 여러 조상 클래스로부터 상속받는 것이 가능한 다중상속을 허용하나 자바에서는 오직 단일 상속만 허용
- 다중상속 허용 시 복합적인 기능을 가진 클래스를 쉽게 작성할 수 있으나 클래스 간 관계가 매우 복잡해져 서로 다른 클래스로부터 상속받은 멤버간 이름이 같을 경우 구별할 수 있는 방법이 없다는 단점을 지님
- 단일 상속은 하나의 조상 클래스만을 가져 클래스 간 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있게 만들어줌

### 1.5. Object클래스 - 모든 클래스의 조상

Object 클래스: 모든 클래스 상속계층도의 최상위에 있는 조상클래스
*타 클래스로부터 상속받지 않는 모든 클래스들은 자동적으로 Object클래스로부터 상속받게 해 가능(예: class Tv (extends Object))*

- Object클래스는 모든 클래스의 조상이 되며, 타 클래스한테 상속을 받더라도 상속 계층도에 따라 마지막 최상위 조상은 Object클래스로 종결
*Object클래스에는 모든 인스턴스가 가져야할 기본적인 11개의 메서드가 정리되어 있음*

***

## 2. 오버라이딩(overriding)

### 2.1. 오버라이딩이란?

오버라이딩: 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것
*상속받은 메서드를 그대로 사용하기도 하지만, 자손 클래스 자신에 맞게 변경해야하는 경우 사용*

### 2.2. 오버라이딩의 조건

오버라이딩은 메서드의 내용만을 새로 작성하는 것으로 메서드의 선언부는 조상의 것과 완전히 일치해야하며, 성립하기 위해 따라야할 조건

1. 같은 이름 사용
2. 같은 매개변수
3. 같은 반환타입
*jdk1.5부터 공변 반환타입(covariant return type) 추가로 반환타입을 자손 클래스의 타입으로 변경하는 것은 가능하도록 조건 완화*
=> 선언부가 서로 일치해야하나 접근 제어자(access modifier)와 예외(exception)는 제한된 조건 하에서만 다르게 변경 가능

#### 1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없음

- 조상 클래스에서 정의된 메서드의 접근 제어자가 protected일 경우, 오버라이딩하는 자손 클래스의 메서드는 접근 제어자가 protected/public이여야 함.
- 대부분 같은 범위의 접근 제어자를 사용함
public -> protected -> (default) -> private (접근범위 넓은 것부터 좁은 순으로)

#### 2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없음

- 선언된 예외의 갯수가 문제 가아니라 예외 자체의 갯수를 봐야함

##### 조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때

1. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경 불가
2. 예외는 조상 클래스의 메서드보다 많이 선언 불가
3. 인스턴스메서드를 static메서드로 또는 그 반대로 변경 불가

##### 조상 클래스에 정의된 static 메서드를 자손 클래스에서 똑같은 이름의 static메서드로 정의 가능 여부

- 가능하나 각 클래스에 별개의 static메서드를 정의한 것일 뿐 오버라이딩은 아님
- 각 메서드는 클래스이름으로 구별되며 호출 시 참조변수.메서드이름() 대신 클래스이름.메서드이름() 을 선호
- static멤버들은 자신들이 정의된 클래스에 묶여있다고 간주

===

### 2.3. 오버로딩 vs 오버라이딩

**오버로딩(overloading)**: 기존에 없는 새로운 메서드를 정의하는 것(new)
**오버라이딩(overriding)**: 상속받은 메서드의 내용을 변경하는 것(change, modify)

### 2.4. super

- super: 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수
- 멤버변수와 지역변수 이름이 같을 때는 this를 붙여 구별, 상속받은 멤버와 자신의 멤버와 이름이 같을 땐 super을 붙여 구별
- 조상 클래스로부터 상속받은 멤버도 자손 클래스 자신의 멤버여서 super대신 this를 사용할 수 있으나 중복 정의로 서로 구별해야하는 경우에만 super 사용
- 모든 인스턴스메서드에는 자신이 속한 인스턴스 주소가 지역변수로 저장되는데 이 값이 참조변수인 this와 super 값이 됨
- static메서드(클래스메서드)는 인스턴스와 관련이 없으며 this와 마찬가지로 super도 static 메서드에서는 사용 불가 => 인스턴스 메서드에서만 사용 가능
- 조상 클래스에 선언된 멤버변수와 같은 이름의 멤버변수를 자손 클래스에서 중복 정의하는 것이 가능하며 참조변수 super을 사용해 서로 구별이 가능하며 호출도 가능한데, 조상 클래스의 메서드를 자손 클래스에서 오버라이딩 한 경우 super 사용

### 2.5. super() - 조상 클래스의 생성자

- this()는 같은 클래스의 타 생성자를 호출할 시 사용, super()은 조상 클래스의 생성자를 호출하는데 사용
- 자손 클래스의 인스턴스를 생성시, 자손의 멤버와 조상의 멤버가 합쳐진 하나의 인스턴스 생성 => 자손 클래스의 인스턴스가 조상 클래스의 멤버 모두 사용 가능
*조상 클래스 멤버 초기화 작업이 수행되어야 하기에 자손 클래스 생성자에서 조상 클래스 생성자 호출 필요*
- 생성자의 첫 줄에서 조상클래스의 생성자를 호출하는 이유: 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있기에 조상 멤버들의 앞선 초기화 필요
*최종적으로 모든 클래스의 최고 조상 Object클래스의 생성자인 Object()까지 올라가야함*
- Object 클래스를 제외한 모든 클래스의 생성자는 첫 줄에 반드시 자신의 다른 생성자(this.()) 또는 조상의 생성자(super()) 호출이 필요하며, 그렇지 않으면 컴파일러는 생성자의 첫 줄에 super();을 자동적으로 추가

#### 인스턴스 생성 시 클래스를 선택하는 것만큼 생성자를 선택하는 것도 중요

- 클래스: 어떤 클래스의 인스턴스를 생성할 것인가?
- 생성자: 선택한 클래스의 어떤 생성자를 이용해서 인스턴스를 생성할 것인가?

- 조상 클래스의 멤버변수는 이처럼 조상의 생성자에 의해 초기화되도록 해야하는 것

***

## 3. package와 import

### 3.1. 패키지(package)

- 패키지: 클래스의 묶음으로 클래스 또는 인터페이스를 포함시키며 서로 관련된 클래스들끼리 그룹 단위로 묶어놓아 클래스를 효율적으로 관리할 수 있음
*같은 이름의 클래스도 서로 다른 패키지에 존재하는 것이 가능해, 자신만의 패키지 체계를 유지함으로써 타 개발자가 개발한 클래스 라이브러리 클래스와 이름이 충돌하는 것을 막을 수 있음*
- 클래스의 실제이름(full name)은 패키지명 포함(예: java.lang.String는 java.lang패키지에 속한 String클래스로 java 서브디렉토리 lang에 속한 String.class파일)으로 같은 이름의 클래스라도 서로 다른 패키기에 속하면 패키지명으로 구별 가능
- 클래스가 물리적으로 하나의 클래스파일(.class)인 것과 같이 패키지는 물리적으로 하나의 디렉토리로 어떤 패키지에 속한 클래스는 해당 디렉토리에 존재하는 클래스 파일(.class)이어야함
- String 클래스는 rt.jar 파일에 압축되어 있으며, 패키지도 다른 패키지를 포함할 수 있으며 점(.)으로 구별

#### 패키지 조건

1. 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언 만을 허용
2. 모든 클래스는 반드시 하나의 패키지에 속해야함
3. 패키지는 점(.)을 구분자로 하여 계층 구조로 구성할 수 있음
4. 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리임

### 3.2. 패키지의 선언

- 선언 방법: 클래스 / 인터페이스의 소스파일(.java)의 맨 위에 package 패키지명; 을 작성
- 패키지 선언문은 반드시 소스파일에서 주석과 공백을 제외한 **첫 번째 문장**이여야 하며 **하나의 소스파일에 단 한 번만 선언** 가능
- 패캐지는 대소문자를 모두 허용하나 클래스명과 쉽게 구분하기 위해 **소문자로 하는 것이 원칙**
- 패키지를 포함하지 않아도 기본적으로 제공하는 이름없는 패키지(unnamed package)가 존재
- 소스 파일에 자신이 속할 패키지를 지정하지 않은 클래스는 자동으로 이름없는 패키지에 속함
- 큰 프로젝트나 Java API같은 클래스 라이브러리를 작성하는 경우 미리 패키지를 구성하여 적용

### 3.3. import문

- 소스코드를 작성할 때 다른 패키지의 클래스를 사용하려면 패키지명이 포함된 클래스 이름을 사용해야하나, 매번 패키지명을 붙여 작성해야함
- 클래스의 코드를 작성하기 전 import문으로 사용하고자 하는 클래스의 패키지를 미리 명시할 시 소스코드에 사용되는 클래스이름에서 패키지명에서 패키지명 생략 가능
- import 역할: **컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공하는 것**
- 컴파일 시 컴파일러는 import문을 통해 소스파일에 사용된 클래스들의 패키지를 알아낸 후, 모든 클래스 이름 앞에 패키지명을 붙임

### 3.4. import문의 선언

- 모든 소스파일(.java)에서 import문은 package문 다음에, 그리고 클래스 선언문 이전에 위치해야함
- import문은 package문과 달리 한 소스파일에 여러 번 선언 가능

#### 일반적인 소스파일(*java)의 구성 순서

1. package문
2. import문
3. 클래스 선언

#### import 선언 방법

import 패키지명.클래스명; / import 패키지명.*;

===

- 키워드 import와 패키지명을 생략하고자 하는 클래스의 이름을 패키지명과 함께 써주면 됨
- 같은 패키지에서 여러 클래스가 사용될 때, import문을 여러번 사용하는 대신 패키지명.*을 사용해 지정된 패키지에 속하는 모든 클래스를 패키지명 없이 사용 가능(실행 성능상 차이는 전혀 없음)
- 패키지.*;은 일일이 클래스의 이름을 지정하는 수고를 덜지만 어느 클래스가 어느 패키지에 속하는지 구별하기 어려워짐
- * 사용이 하위 패키지의 클래스까지 포함되는 것이 아님
- import java.lang.*;은 기본으로 묵시적 선언돼서 패키지명 없이 사용 가능

### 3.5. static import문

- import문을 ㅏㅅ용하면 클래스의 패키지명을 생략할 수 있 듯이 static import문 사용시 static멤버를 호출 시 클래스 이름 생략 가능
- 특정 클래스의 static멤버를 자주 사용할 때 편리하며 코드가 간결해짐

***

## 4. 제어자(modifier)

### 4.1. 제어자란?

- 제어자(modifier): 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여


#### 제어자 종류

- 접근 제어자: public, protected, default, private
- 그 외 제어자: static, final, abstract, native, transient, synchronized, volatile, strictfp

===

- 제어자는 클래스나 멤버변수와 메서드에 주로 사용되며, 하나의 대상에 대해 여러 제어자를 조합해 사용하는 것이 가능
- 접근 제어자는 한 번에 네 가지 중 하나만 선택해 사용

***

### 4.2. static - 클래스의 , 공통적인

- static은 클래스의 / 공통적인 의미를 지님
- 인스턴스변수는 하나의 클래스로부터 생성됐더라도 각기 다른 값을 유지하나, 클래스변수(static멤버변수)는 인스턴스에 관계없이 같은 값을 가짐
=> 하나의 변수를 모든 인스턴스가 공유하기 때문
- static이 붙은 멤버변수와 메서드, 초기화 블럭은 인스턴스가 아닌 클래스에 관계된 것으로 인스턴스를 생성하지 않고도 사용 가능
- 인스턴스 메서드와 static메서드의 근본적인 차이: 메서드 내에서 인스턴스 멤버를 사용하는가의 여부

#### static이 사용될 수 있는 곳: 멤버변수, 메서드, 초기화 블럭

#### static

##### 멤버변수

- 모든 인스턴스에 공통적으로 사용되는 클래스변수가 됨
- 클래스변수는 인스턴스를 생성하지 않고도 사용 가능
- 클래스가 메모리에 로드될 때 생성

##### 메서드

- 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 됨
- static 메서드 내 인스턴스 멤버들을 직접 사용 불가

===

- 인스턴스 멤버를 사용하지 않는 메서드는 static을 붙여 static메서드로 선언 추천
- static메서드는 인스턴스를 생성하지 않고도 호출이 가능해 더 편하고 속도가 빠름
*static초기화 블럭은 클래스가 메모리에 로드될 때 단 한 번만 수행되며, 주로 클래스변수(static변수)를 초기화하는데 주로 사용*

### 4.3. final - 마지막의, 변경될 수 없는

- final: 마지막의 / 변경될 수 없는 의미로 거의 모든 대상에 사용
- 변수에 사용되면 값을 변경할 수 없는 상수가 되며, 메서드에 사용하면 오버라이딩 불가, 클래스에 사용하면 자신을 확장하는 자손 클래스 정의 불가

#### final이 사용될 수 있는 곳: 클래스, 메서드, 멤버변수, 지역변수

#### final

- 클래스: 변경될 수 없는 클래스, 확장될 수 없는 클래스가 되며, final로 지정된 클래스는 다른 클래스의 조상이 될 수 없음
- 메서드: 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩으로 재정의 불가
- 멤버 / 지역 변수: 변수 앞에 final이 붙으면 값 변경 불가 상수가 됨
*대표적인 final 클래스로 String과 Math가 있음*

#### 생성자를 이용한 final멤버 변수의 초기화

- final이 붙은 변수는 상수로 일반적으로 선언과 초기화를 동시에 하나, 인스턴스변수의 경우 생성자에서 초기화되도록 할 수 있음
- 클래스 내 매개변수를 갖는 생성자를 선언해, 인스턴스를 생성할 때 final이 붙은 멤버변수를 초기화하는데 필요한 값을 생성자의 매개변수로부터 제공받는 것
- 각 인스턴스마다 final이 멤버변수가 다른 값을 갖도록 하는 것이 가능
- 불가능할 경우 클래스에 선언된 final이 붙은 인스턴스변수는 모든 인스턴스에서 같은 값을 가져야만 함
*예: 카드는 다른 종류와 숫자를 갖지만, 일단 카드가 생성될 시 카드의 값이 변경되면 안되기에 값을 바꾸기보다 카드의 순서를 바꾸는 방법을 선호*

===

### 4.4. abstract - 추상의, 미완성의

- abstract: 미완성의 의미로 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용
- 클래스에 사용되어 클래스 내에 추상메서드가 존재한다는 것을 쉽게 알 수 있게 함

#### abstract가 사용될 수 있는 곳: 클래스, 메서드

#### abstract

- 클래스: 클래스 내에 추상 메서드가 선언되어 있음을 의미
- 메서드: 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알림

===

- 추상 메서드가 없는 클래스, 완성된 클래스도 abstract를 붙여 만드는 경우가 있는데, 인스턴스를 생성해도 아무것도 할 수 있는 것이 없는 경우 인스턴스를 생성하지 못하도록 클래스 앞에 제어자를 붙임(예: java.awt.event.WindowAdapter)
- 클래스 자체로는 쓸모가 없으나, 타 클래스가 이 클래스를 상속받아 일부의 원하는 메서드만 오버라이딩 해도 되는 장점 존재
- 클래스가 없을 시 아무런 내용도 없는 메서드를 잔뜩 오버라이딩해야함

### 4.5. 접근 제어자(access modifier)

- 접근 제어자: 멤버 또는 클래스에 사용, 해당하는 맴버 또는 클래스를 외부에서 접근하지 못하도록 제한
- 접근 제어자가 default는 실제로 붙이지 않으며, 클래스나 멤버변수, 메서드, 생성자에 접근 제어자가 지정되어 있지 않으면 접근 제어자: default

#### 접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메서드, 생성자

- private: 같은 클래스 내에서만 접근 가능
- default: 같은 패키지 내에서만 접근 가능
- protected: 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근 가능
- public: 접근 제한 없음

#### 접근 범위가 넓은 쪽에서 좁은 쪽 순서: public > protected > (default) > private

===

- public은 접근 제한이 전혀 없고 private는 같은 클래스 내에서만 사용하도록 제한하는 가장 높은 제한, default는 같은 패키지 내 클래스에서만 접근이 가능
- protected는 패키지에 관계없이 상속 관계에 있는 자손 클래스에서 접근할 수 있도록 하는 것이 제한 목적이지만, 같은 패키지 내에서도 접근 가능
=> protected가 default보다 접근범위가 더 넓음
*접근 제어자가 default라는 것은 아무런 접근 제어자도 붙이지 않는 것을 의미*

#### 사용 가능한 접근 제어자

- 클래스: public, (default)
- 메서드 / 멤버변수: public, protected, (default), private
- 지역변수: 없음

#### 접근 제어자를 이용한 캡슐화

- 클래스나 멤버, 주로 멤버에 접근 제어잘르 사용하는 이유는 클래스의 내부에 선언된 데이터를 보호 목적
- 데이터가 유효한 값을 유지하도록, 혹은 비밀번호와 같은 대이터를 외부에서 함부로 변경하지 못하도록 하기 위해 외부로부터 접근을 제어하는 것이 필요
- == 데이터 감추기(data hiding), 객체지향개념의 캡슐화(encapsulation)
- 클래스 내에서만 사용되는, 내부 작업을 위해 임시로 사용되는 멤버변수나 부분작업을 처리하기 위한 메서드 등의 멤버들을 클래스 내부에 감추기 위한 목적
- 외부에서 접근할 필요가 없는 멤버들을 private로 지정해 외부에 노출시키지 않음으로 복잡성을 줄일 수 있으며 캡술화에 해당

##### 접근 제어자를 사용하는 이유

- 외부로부터 데이터를 보호하기 위해
- 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위함

===

- 메서드 하나를 변경해야 한다고 가정할 시: 이 메서드의 접근 제어자가 public이라면 메서드를 변경한 후 오류가 없는지 테스트해야하는 범위가 넓지만, 접근 제어자가 default라면 패키지 내부만 확인해보면 되고 private이면 클래스 하나만 살펴보면 됨
- 접근 제어자 하나가 상당 차이를 만들 수 있으므로 적절히 선택해 접근 범위를 최소화하도록 권유
- 멤버변수에 잘못된 값을 지정하지 못하도록 private나 protected로 제한하고 멤버변수의 값을 읽고 변경할 수 있는 public 메서드를 제공함으로써 간접적으로 멤버변수의 값을 다룰 수 있도록 권유

- get으로 시작하는 메서드: 단순 멤버변수 값 반환
- set으로 시작하는 메서드: 매개변수에 지정된 값을 검사해 조건에 맞는 값일 때만 멤버변수의 값을 변경하도록 작성
- 상속을 통해 확장될 것이 예상되는 클래스일 시 멤버에 접근 제한을 주되 자손 클래스에서 접근하는 것이 가능해지도록 protected 사용
*private가 붙은 멤버는 자손 클래스에서도 접근이 불가하기 때문*

- get멤버변수이름(겟터): 멤버변수의 값을 읽는 메서드의 이름
- set멤버변수이름(셋터): 멤버변수의 값을 변경하는 메서드의 이름
- time클래스의 모든 멤버변수의 접근 제어자를 private로 하고, 이 둘을 다루기 위해 public 메서드를 추가하면 멤버변수로부터의 직접적인 접근 허용이 불가되며, 메서드를 통한 접근만 허용(예: t.hour=13;)
*하나의 소스파일(.java)에는 public클래스가 단 하나만 존재할 수 있으며, 소스파일의 이름은 반드시 public클래스의 이름과 같아야함*

##### 생성자의 접근 제어자

- 생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한 가능
- 보통은 생성자의 접근 제어자는 클래스의 접근 제어자와 같지만, 다르게 지정 가능
- 생성자의 접근 제어자를 private로 지정하면, 외부에서 생성자에 접근할 수 없으므로 인스턴스 생성은 불가하나 클래스 내부에서는 인스턴스 생성 가능
*대신 인스턴스를 생성해서 반환해주는 public메서드를 제공함으로써 외부에서 이 클래스의 인스턴스를 사용하도록 할 수 있으며, 이 메서드는 public인 동시에 static이여야함*
- 생성자를 통해 직접 인스턴스를 생성하지 못하게 하고 public 메서드를 통해 인스턴스에 접근하게 함으로써 사용할 수 있는 인스턴스의 개수 제한 가능
- 생성자가 private인 클래스는 타 클래스의 조상 불가: 자손 클래스의 인스턴스를 생성할 때 조상 클래스의 생성자를 호출해야하만 하는데, 생성자의 접근 제어자가 private이므로 자손 클래스에서 호출하는 것이 불가능하기 때문
=> 클래스 앞에 final을 더 추가해 상속할 수없는 클래스라는 것을 알리는 것이 좋음
- Math클래스는 몇 개의 상수와 static메서드만으로 구성되어 있기 때문에 인스턴스를 생성할 필요가 없으며, 외부로부터 불필요한 접근을 막기 위해 다음과 같이 생성자의 접근 제어자를 private로 지정

===

### 4.6. 제어자(modifier)의 조합

|대상|사용 가능한 제어자|
|---|---|
|클래스|public, (default), final, abstract|
|메서드|모든 접근 제어자, final, abstract, static|
|멤버변수|모든 접근 제어자, final, static|
|지역변수|final|

#### 제어자를 조합해서 사용할 때 주의해야할 사항

##### 1. 메서드에 static과 abstract를 함께 사용할 수 없다

- static메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문

##### 2. 클래스에 abstract와 final을 동시 사용 불가

- 클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고 abstract는 상속을 통해 완성되어야 한다는 의미로 서로 모순

##### 3. abstract메서드의 접근 제어자가 private일 수 없음

- abstract메서드는 자손 클래스에서 구현해주어야 하는데 접근 제어자가 private면 자손 클래스에서 접근이 불가하기 때문

##### 4. 메서드에 pricate와 final을 같이 사용할 필요는 없음

- 접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문에 둘 중 하나만 사용해도 의미가 충분

***

## 5. 다형성(polymorphism)

### 5.1. 다형성이란?

- 객체지향개념의 중요한 특징 중 하나
- 다형성: 여러 가지 형태에서 가질 수 있는 능력을 의미
- 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 해 다형성을 프로그램적으로 구현
- 조상클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조할 수 있도록 하였다는 것
- 인스턴스 타입과 참조변수의 타입이 일치하는 것이 보통이나, tv/CaptionTv클래스가 서로 상속관계에 있을 경우 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조하도록 하는 것도 가능

#### 인스턴스를 같은 타입의 참조변수로 참조하는 것과 조상타입의 참조변수로 참조하는 것의 차이점

CaptionTv c=new CaptionTv();
Tv t=new CaptionTv();

- CaptionTv인스턴스가 2개면서, 참조변수 c와 t가 생성된 인스턴스를 하나씩 참조한다고 할 때, 실제 인스턴스가 CaptionTv타입일지도 참조변수 t로는 CaptionTv인스턴스의 모든 멤버 사용 불가(Tv타입의 참조변수로는 CaptionTv인스턴스 중에서 Tv클래스의 멤버들(상속받은 멤버포함)만 사용 가능)
=> 생성된 CaptionTv인스턴스의 멤버 중에서 Tv클래스에 정의되지 않은 멤버, Text와 caption()은 참조변수 t로 사용이 불가능하며, 이는 t.text / t.caption() 사용 불가
- 둘 다 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라짐

#### 자손 타입의 참조변수로 조상타입의 인스턴스를 참조하는 것이 가능한가?

CaptionTv c=new Tv();

- 실제 인스턴스인 Tv의 멤버 개수보다 참조변수 c가 사용할 수 있는 멤버 개수가 더 많기 때문에 이를 허용하지 않음, 에러
- CaptionTv클래스에는 text와 caption()이 정의되어 있으므로 참조변수 c로는 c.text, c.caption()과 같은 방식으로 c가 참조하고 있는 인스턴스에서 text와 caption()을 사용하려 할 수 있음
- 그러나, c가 참조하고 있는 인스턴스는 Tv타입이고, Tv타입의 인스턴스에는 text와 caption()이 존재하지 않기에 이들을 사용하려 하면 문제 발생

===

- 자손타입의 참조 변수로 조상타입의 인스턴스를 참조하는 것은 존재하지 않은 멤버를 사용하고자 할 가능성이 존재해서 허용하지 않으며, 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야함
*클래스는 상속을 통해 확장될 수는 있어도 축소될 수는 없어서, 조상 인스턴스의 멤버 개수는 자손 인스턴스의 멤버 개수보다 항상 적거나 같음*
*모든 참조변수는 null 또는 4 byte의 주소값이 저장되며, 참조변수의 타입은 참조할 수 있는 객체의 종류와 사용할 수 있는 멤버의 수를 결정*

##### 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있음

##### 반대로 자손 타입의 참조변수로 조상타입의 인스턴스 참조 불가

===

### 5.2. 참조변수의 형변환

- 기본형 변수와 같이 참조변수도 형변환이 가능
- 서로 상속관계에 있는 클래스사이에서만 가능하기 때문에 자손타입의 참조변수를 조상타입의 참조변수로, 조상타입의 참조변수를 자손타입의 참조변수로의 형변환만 가능
*바로 윗 조상이나 자손이 아닌, 조상의 조상으로도 형변환이 가능함에 따라, 모든 참조변수는 모든 클래스의 조상인 Object클래스 타입으로 형변환이 가능*
- 기본형 변수의 형변환에서 작은 자료형 -> 큰 자료형의 형변환은 생략이 가능하듯, 참조형 변수의 형변환에서는 자손타입의 참조변수를 조상타입으로 형변환하는 경우 형변환 생략 가능

#### 자손타입 -> 조상타입(up-casting): 형변환 생략가능

#### 자손타입 <- 조상타입(Down-casting): 형변환 생략불가

- 다운캐스팅(Down-casting): 조상타입의 참조변수를 자손타입의 참조변수로 변환하는 것
- 업캐스팅(Up-casting): 자손타입의 참조변수를 조상타입의 참조변수로 변환하는 것
- 참조변수간 형변환 역시 캐스트연산자를 사용하며, 괄호()안에 변환하고자 하는 타입의 이름(class 명)을 적어주면 됨
- 조상은 하나로 두며 자식 간 클래스는 형제관계가 아니기에 상속 관계가 아닌 클래스 간에는 서로 형변환 불가
- 자손타입의 참조변수를 조상타입의 참조변수에 할당할 경우 형변환 생략 가능(예: car=fe; == car=(Car)fe;)
- 조사타입의 참조변수를 자손타입의 참조변수에 저장할 경우 형변환 생략 불가(예: fe2=(FireEngine)car;)

#### 형변환 생략 가능 경우 / 생략 불가 경우

- Car타입 참조변수 c가 존재한다는 가정 하에, 참조변수 c가 참조하고 있는 인스턴스가 Car인스턴스 / 자손인 FireEngine 인스턴스일 경우
- Car타입 참조변수 c를 Car타입의 조상인 Object 타입의 참조변수로 형변환하는 것은 참조변수가 다룰 수 있는 멤버의 개수가 실제 인스턴스가 갖고 있는 멤버의 개수보다 적을 것이 분명하므로 문제가 되지 않기에 형변환 생략 가능
- Car타입의 참조변수 c를 자손인 FireEngine타입으로 변환하는 것은 참조변수가 다룰 수 있는 멤버의 개수를 늘리는 것으로, 실제 인스턴스의 멤버 개수보다 참조변수가 사용할 수 있는 멤버의 개수가 더 많아지므로 문제 발생 가능성 존재
=> 자손 타입 형변환은 생략 불가로, 형변환을 수행하기 전 instanceof 연산자를 사용해 참조변수가 참조하고 있는 실제 인스턴스 타입을 확인하는 것이 안전
- 형변환은 참조변수의 타입을 변환하는 것으로 인스턴스를 변환하는 것이 아니기에 참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않음
- 단지 참조변수의 형변환을 통해 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것일 뿐임
